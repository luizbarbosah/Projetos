//! momento.js
//! versão: 2.29.3
//! autores: Tim Wood, Iskren Chernev, colaboradores do Moment.js
//! licença: MIT
//! momentjs. com

;(função (global, fábrica) {
    typeof export === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(fábrica):
    global.moment = fábrica()
}(this, (function() { 'use strict';

    var hookCallback;

    função ganchos() {
        return hookCallback.apply(null, argumentos);
    }

    // Isso é feito para registrar o método chamado com moment()
    // sem criar dependências circulares.
    function setHookCallback(retorno de chamada) {
        hookCallback = retorno de chamada;
    }

    function isArray(entrada) {
        Retorna (
            input instanceof Array ||
            Object.prototype.toString.call(input) === '[object Array]'
        );
    }

    function isObject(input) {
        // IE8 tratará undefined e null como objeto se não fosse por
        // entrada != null
        Retorna (
            entrada != null &&
            Object.prototype.toString.call(input) === '[object Object]'
        );
    }

    function temPropriedade(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
        } senão {
            vark;
            para (k em obj) {
                if (hasOwnProp(obj, k)) {
                    retorna falso;
                }
            }
            retorne verdadeiro;
        }
    }

    function isUndefined(input) {
        entrada de retorno === void 0;
    }

    função éNúmero(entrada) {
        Retorna (
            typeof input === 'number' ||
            Object.prototype.toString.call(input) === '[Número do objeto]'
        );
    }

    função éData(entrada) {
        Retorna (
            input instanceof Date ||
            Object.prototype.toString.call(input) === '[data do objeto]'
        );
    }

    função map(arr, fn) {
        var res = [],
            eu,
            arrLen = arr.comprimento;
        for (i = 0; i < arrLen; ++i) {
            res.push(fn(arr[i], i));
        }
        retorno res;
    }

    função extend(a,b){
        para (var i em b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valorOf = b.valorOf;
        }

        retornar um;
    }

    function createUTC(entrada, formato, localidade, estrito) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // Precisamos clonar profundamente este objeto.
        Retorna {
            vazio: falso,
            Tokens não utilizados: [],
            entrada não utilizada: [],
            estouro: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            inválidoFormato: falso,
            userInvalidated: false,
            iso: falso,
            parsedDateParts: [],
            época: nulo,
            meridiano: null,
            rfc2822: falso,
            dia da semanaIncompatibilidade: falso,
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        retornar m._pf;
    }

    var alguns;
    if (Array.prototype.some) {
        alguns = Array.prototype.some;
    } senão {
        algum = função (diversão) {
            var t = Objeto(este),
                len = t.comprimento >>> 0,
                eu;

            for (i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    retorne verdadeiro;
                }
            }

            retorna falso;
        };
    }

    função éValida(m){
        if (m._isValid == null) {
            var flags = getParsingFlags(m),
                parsedParts = some.call(flags.parsedDateParts, function (i) {
                    return i != null;
                }),
                isNowValid =
                    !isNaN(m._d.getTime()) &&
                    flags.overflow < 0 &&
                    !flags.empty &&
                    !flags.invalidEra &&
                    !flags.invalidMonth &&
                    !flags.invalidWeekday &&
                    !flags.weekdayIncompatibilidade &&
                    !flags.nullInput &&
                    !flags.invalidFormat &&
                    !flags.userInvalidated &&
                    (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid =
                    isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === indefinido;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            } senão {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid(sinalizadores) {
        var m = criarUTC(NaN);
        if (sinalizadores != null) {
            extend(getParsingFlags(m), flags);
        } senão {
            getParsingFlags(m).userInvalidated = true;
        }

        retornar m;
    }

    // Plugins que adicionam propriedades também devem adicionar a chave aqui (valor nulo),
    // para que possamos nos clonar corretamente.
    var momentProperties = (hooks.momentProperties = []),
        atualizaçãoInProgress = false;

    function copyConfig(para, de) {
        var eu,
            suporte,
            vale,
            momentPropertiesLen = momentProperties.length;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            para._i = de._i;
        }
        if (!isUndefined(from._f)) {
            para._f = de._f;
        }
        if (!isUndefined(from._l)) {
            para._l = de._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            para._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentPropertiesLen > 0) {
            for (i = 0; i < momentoPropriedadesLen; i++) {
                prop = momentoPropriedades[i];
                val = de[prop];
                if (!isUndefined(val)) {
                    para[prop] = val;
                }
            }
        }

        voltou para;
    }

    // Objeto protótipo de momento
    function Momento(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Evita loop infinito caso updateOffset crie um novo momento
        // objetos.
        if (updateInProgress === false) {
            atualizaçãoInProgress = true;
            hooks.updateOffset(this);
            atualizaçãoInProgress = false;
        }
    }

    function isMoment(obj) {
        Retorna (
            obj instanceof Momento || (obj != null && obj._isAMomentObject != null)
        );
    }

    função avisar(msg) {
        E se (
            hooks.suppressDeprecationWarnings === false &&
            typeof console !== 'undefined' &&
            console.aviso
        ) {
            console.warn('Aviso de descontinuação: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var primeirahora = true;

        return estender(função() {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (primeira vez) {
                var argumentos = [],
                    argumento,
                    eu,
                    chave,
                    argLen = argumentos.comprimento;
                for (i = 0; i <argLen; i++) {
                    argumento = '';
                    if (tipo de argumentos[i] === 'objeto') {
                        arg += '\n[' + i + '] ';
                        for (digite argumentos[0]) {
                            if (hasOwnProp(argumentos[0], chave)) {
                                arg += chave + ': ' + argumentos[0][chave] + ', ';
                            }
                        }
                        arg = arg.fatia(0, -2); // Remove vírgula e espaço à direita
                    } senão {
                        arg = argumentos[i];
                    }
                    args.push(arg);
                }
                avisar(
                    mensagem +
                        '\nArgumentos: ' +
                        Array.prototype.slice.call(args).join('') +
                        '\n' +
                        new Error().stack
                );
                primeirahora = false;
            }
            return fn.apply(this, argumentos);
        }, f);
    }

    var depreciações = {};

    function deprecateSimple(nome, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(nome, msg);
        }
        if (!deprecations[nome]) {
            avisar(msg);
            depreciações[nome] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    ganchos.deprecationHandler = null;

    função éFunção(entrada) {
        Retorna (
            (typeof Function !== 'undefined' && input instanceof Function) ||
            Object.prototype.toString.call(input) === '[função do objeto]'
        );
    }

    função set(config) {
        var prop, i;
        para (i na configuração) {
            if (hasOwnProp(config, i)) {
                prop = config[i];
                if (isFunction(prop)) {
                    este[i] = prop;
                } senão {
                    this['_' + i] = prop;
                }
            }
        }
        this._config = config;
        // A análise ordinal leniente aceita apenas um número além de
        // número + (possivelmente) coisas provenientes de _dayOfMonthOrdinalParse.
        // TODO: Remova o fallback "ordinalParse" na próxima versão principal.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' +
                /\d{1,2}/.source
        );
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig),
            suporte;
        for (prop em childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } senão {
                    delete res[prop];
                }
            }
        }
        for (prop em parentConfig) {
            E se (
                hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])
            ) {
                // certifique-se de que as alterações nas propriedades não modifiquem a configuração pai
                res[prop] = extend({}, res[prop]);
            }
        }
        retorno res;
    }

    function Locale(config) {
        if (config!= null) {
            this.set(config);
        }
    }

    chaves var;

    if (Object.keys) {
        chaves = Object.keys;
    } senão {
        teclas = função (obj) {
            var eu,
                res = [];
            para (i em obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            retorno res;
        };
    }

    var defaultCalendar = {
        SameDay: '[Hoje às] LT',
        nextDay: '[Amanhã às] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Ontem às] LT',
        lastWeek: '[Último] dddd [às] LT',
        sameElse: 'L',
    };

    function calendar(key, mom, now) {
        var output = this._calendar[chave] || this._calendar['sameElse'];
        return isFunction(saída) ? output.call(mãe, agora): output;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(número),
            zerosToFill = targetLength - absNumber.length,
            sinal = número >= 0;
        Retorna (
            (sinal ? (forceSign ? '+' : ''): '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
            absNumero
        );
    }

    var formattingTokens =
            /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd ?d?|faz?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo? |gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz ?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        formatFunctions = {},
        formatTokenFunctions = {};

    // token: 'M'
    // preenchido: ['MM', 2]
    // ordinal: 'Mo'
    // retorno de chamada: function () { this.month() + 1 }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = retorno de chamada;
        if (typeof callback === 'string') {
            função = função() {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (preenchido) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        se (ordinal) {
            formatTokenFunctions[ordinal] = function() {
                return this.localeData().ordinal(
                    func.apply(isto, argumentos),
                    símbolo
                );
            };
        }
    }

    function removeFormattingTokens(entrada) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(formato) {
        var array = format.match(formattingTokens),
            eu,
            comprimento;

        for (i = 0, comprimento = array.comprimento; i < comprimento; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } senão {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        função de retorno (mãe) {
            var saída = '',
                eu;
            for (i = 0; i < comprimento; i++) {
                output += isFunction(array[i])
                    ? array[i].call(mãe, formato)
                    : array[i];
            }
            saída de retorno;
        };
    }

    // formata a data usando o objeto de data nativo
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        formato = expandFormat(formato, m.localeData());
        formatFunctions[formato] =
            formatFunctions[formato] || makeFormatFunction(formato);

        return formatFunctions[formato](m);
    }

    function expandFormat(formato, localidade) {
        var i = 5;

        função replaceLongDateFormatTokens(entrada) {
            return locale.longDateFormat(input) || entrada;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            formato = formato.substituir(
                localFormattingTokens,
                replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        formato de retorno;
    }

    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/AAAA',
        LL: 'MMMM D, AAAA',
        LLL: 'MMMM D, AAAA h:mm A',
        LLLL: 'dddd, MMMM D, AAAA h:mm A',
    };

    function longDateFormat(chave) {
        var formato = this._longDateFormat[chave],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (formato || !formato Superior) {
            formato de retorno;
        }

        this._longDateFormat[key] = formatUpper
            .match(formattingTokens)
            .map(função (tok) {
                E se (
                    tok === 'MMMM' ||
                    tok === 'MM' ||
                    tok === 'DD' ||
                    tok === 'dddd'
                ) {
                    return tok.slice(1);
                }
                retorno tok;
            })
            .Junte('');

        return this._longDateFormat[chave];
    }

    var defaultInvalidDate = 'Data inválida';

    function data invalid() {
        retorne this._invalidDate;
    }

    var defaultOrdinal = '%d',
        defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    função ordinal (número) {
        return this._ordinal.replace('%d', número);
    }

    var defaultRelativeTime = {
        futuro: 'em %s',
        passado: '%s atrás',
        s: 'alguns segundos',
        ss: '%d segundos',
        m: 'um minuto',
        mm: '%d minutos',
        h: 'uma hora',
        hh: '%d horas',
        d: 'um dia',
        dd: '%d dias',
        w: 'uma semana',
        ww: '%d semanas',
        M: 'um mês',
        MM: '%d meses',
        y: 'um ano',
        aa: '%d anos',
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(saída)
            ? output(number, withoutSuffix, string, isFuture)
            : output.replace(/%d/i, número);
    }

    function pastFuture(diff, output) {
        var formato = this._relativeTime[diff > 0 ? 'passado Futuro'];
        return isFunction(format) ? format(saída): format.replace(/%s/i, saída);
    }

    var aliases = {};

    function addUnitAlias(unidade, taquigrafia) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] ​​= aliases[lowerCase + 's'] = aliases[shorthand] = unidade;
    }

    function normalizeUnidades(unidades) {
        return typeof unidades === 'string'
            ? pseudônimos[unidades] || aliases[units.toLowerCase()]
            : Indefinido;
    }

    function normalizeObjectUnits(inputObject) {
        var entrada normalizada = {},
            normalizedProp,
            suporte;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var prioridades = {};

    function addUnitPriority(unidade, prioridade) {
        prioridades[unidade] = prioridade;
    }

    function getPrioritizedUnits(unitsObj) {
        var unidades = [],
            você;
        for (u em unidadesObj) {
            if (hasOwnProp(unidadesObj, u)) {
                unidades.push({ unidade: u, prioridade: prioridades[u] });
            }
        }
        unidades.sort(função (a, b) {
            retornar a.prioridade - b.prioridade;
        });
        unidades de retorno;
    }

    function isLeapYear(ano) {
        return (ano % 4 === 0 && ano % 100 !== 0) || ano % 400 === 0;
    }

    function absFloor(número) {
        if (número < 0) {
            // -0 -> 0
            return Math.ceil(número) || 0;
        } senão {
            return Math.floor(número);
        }
    }

    function toInt(argumentoParaCoerção) {
        var coercedNumber = +argumentForCoercion,
            valor = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            valor = absFloor(coercedNumber);
        }

        valor de retorno;
    }

    function makeGetSet(unidade, keepTime) {
        função de retorno (valor) {
            if (valor != null) {
                set$1(isto, unidade, valor);
                hooks.updateOffset(this, keepTime);
                devolva isso;
            } senão {
                return get(isto, unidade);
            }
        };
    }

    função get(mãe, unidade) {
        return mom.isValid()
            ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unidade]()
            : NaN;
    }

    conjunto de funções$1(mãe, unidade, valor) {
        if (mom.isValid() && !isNaN(valor)) {
            E se (
                unidade === 'Ano Completo' &&
                isLeapYear(mãe.ano()) &&
                mãe.mês() === 1 &&
                mom.date() === 29
            ) {
                valor = toInt(valor);
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unidade](
                    valor,
                    mãe.mês(),
                    diasInMês(valor, mãe.mês())
                );
            } senão {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unidade](valor);
            }
        }
    }

    // MOMENTOS

    function stringGet(unidades) {
        unidades = normalizeUnidades(unidades);
        if (isFunction(this[unidades])) {
            return this[unidades]();
        }
        devolva isso;
    }

    function stringSet(unidades, valor) {
        if (tipo de unidades === 'objeto') {
            unidades = normalizeObjectUnits(unidades);
            var priorizado = getPrioritizedUnits(unidades),
                eu,
                priorizadoLen = priorizado.comprimento;
            for (i = 0; i <prioridadeLen; i++) {
                this[priorizou[i].unidade](unidades[priorizou[i].unidade]);
            }
        } senão {
            unidades = normalizeUnidades(unidades);
            if (isFunction(this[unidades])) {
                return this[unidades](valor);
            }
        }
        devolva isso;
    }

    var match1 = /\d/, // 0 - 9
        match2 = /\d\d/, // 00 - 99
        match3 = /\d{3}/, // 000 - 999
        match4 = /\d{4}/, // 0000 - 9999
        match6 = /[+-]?\d{6}/, // -999999 - 999999
        match1to2 = /\d\d?/, // 0 - 99
        match3to4 = /\d\d\d\d?/, // 999 - 9999
        match5to6 = /\d\d\d\d\d\d?/, // 99999 - 999999
        match1to3 = /\d{1,3}/, // 0 - 999
        match1to4 = /\d{1,4}/, // 0 - 9999
        match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
        matchUnsigned = /\d+/, // 0 - inf
        matchSigned = /[+-]?\d+/, // -inf - inf
        matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 ou Z
        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 ou Z
        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        // qualquer palavra (ou dois) caracteres ou números incluindo duas/três palavras mês em árabe.
        // inclui duas palavras em gaélico escocês e meses com hífen
        matchWord =
            /[0-9]{0,256}['az\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/ ]{1.256}(\s*?[\u0600-\u06FF]{1.256}){1,2}/i,
        expressões regulares;

    expressões regulares = {};

    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex)
            ? regex
            : function (isStrict, localeData) {
                  return isStrict && strictRegex ? strictRegex : regex;
              };
    }

    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Código de http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(
            s
                .substituir('\\', '')
                .substituir(
                    /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
                    função (combinado, p1, p2, p3, p4) {
                        retornar p1 || p2 || p3 || p4;
                    }
                )
        );
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, retorno de chamada) {
        var eu,
            func = retorno de chamada,
            tokenLen;
        if (tipo de token === 'string') {
            token = [token];
        }
        if (isNumber(retorno de chamada)) {
            func = function (entrada, array) {
                array[callback] = toInt(input);
            };
        }
        tokenLen = token.comprimento;
        for (i = 0; i < tokenLen; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken(token, retorno de chamada) {
        addParseToken(token, function (entrada, array, config, token) {
            config._w = config._w || {};
            callback(entrada, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, entrada, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var ANO = 0,
        MÊS = 1,
        DATA = 2,
        HORA = 3,
        MINUTO = 4,
        SEGUNDO = 5,
        MILISEGUNDO = 6,
        SEMANA = 7,
        DIA DA SEMANA = 8;

    função mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } senão {
        indexOf = function (o) {
            // Eu sei
            var i;
            for (i = 0; i < this.length; ++i) {
                if (este[i] === o){
                    retorno eu;
                }
            }
            retornar -1;
        };
    }

    função diasEmMês(ano, mês) {
        if (éNaN(ano) || éNaN(mês)) {
            retornar NaN;
        }
        var modMonth = mod(mês, 12);
        ano += (mês - modMonth) / 12;
        return modMonth === 1
            ? isLeapYear(ano)
                ? 29
                : 28
            : 31 - ((modMonth % 7) % 2);
    }

    // FORMATAÇÃO

    addFormatToken('M', ['MM', 2], 'Mo', função () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (formato) {
        return this.localeData().monthsShort(this, formato);
    });

    addFormatToken('MMMM', 0, 0, function (formato) {
        return this.localeData().months(this, formato);
    });

    // APELIDO

    addUnitAlias('mês', 'M');

    // PRIORIDADE

    addUnitPriority('mês', 8);

    // ANALISANDO

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (entrada, array) {
        array[MÊS] = toInt(entrada) - 1;
    });

    addParseToken(['MMM', 'MMMM'], função (entrada, matriz, configuração, token) {
        var mês = config._locale.monthsParse(entrada, token, config._strict);
        // se não encontramos um nome de mês, marque a data como inválida.
        if (mês != null) {
            array[MÊS] = mês;
        } senão {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCAIS

    var defaultLocaleMonths =
            'janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split(
                '_'
            ),
        defaultLocaleMonthsShort =
            'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Out_Nov_Dec'.split('_'),
        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        defaultMonthsShortRegex = matchWord,
        defaultMonthsRegex = matchWord;

    function localeMonths(m, formato) {
        se (!m) {
            return isArray(this._months)
                ? isso._meses
                : this._months['standalone'];
        }
        return isArray(this._months)
            ? this._months[m.month()]
            : this._months[
                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                      ? 'formato'
                      : 'estar sozinho'
              ][m.mês()];
    }

    function localeMonthsShort(m, formato) {
        se (!m) {
            return isArray(this._monthsShort)
                ? this._monthsCurta
                : this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort)
            ? this._monthsShort[m.month()]
            : this._monthsShort[
                  MONTHS_IN_FORMAT.test(format) ? 'formato': 'autônomo'
              ][m.mês()];
    }

    function handleStrictParse(monthName, format, strict) {
        var eu,
            ii,
            mamãe,
            llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // isso não é usado
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            para (i = 0; i < 12; ++i) {
                mãe = criarUTC([2000,i]);
                this._shortMonthsParse[i] = this.monthsShort(
                    mamãe,
                    ''
                ).toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mãe, '').toLocaleLowerCase();
            }
        }

        se (estrito) {
            if (formato === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii: nulo;
            } senão {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii: nulo;
            }
        } senão {
            if (formato === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    retorno ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii: nulo;
            } senão {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    retorno ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii: nulo;
            }
        }
    }

    function localeMonthsParse(monthName, format, strict) {
        var i, mãe, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: adiciona ordenação
        // A classificação garante se um mês (ou abbr) é um prefixo de outro
        // veja a classificação em computeMonthsParse
        for (i = 0; i < 12; i++) {
            // faz a regex se ainda não a tivermos
            mãe = criarUTC([2000,i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp(
                    '^' + this.months(mãe, '').replace('.', '') + '$',
                    'eu'
                );
                this._shortMonthsParse[i] = new RegExp(
                    '^' + this.monthsShort(mãe, '').replace('.', '') + '$',
                    'eu'
                );
            }
            if (!strict && !this._monthsParse[i]) {
                regex =
                    '^' + this.months(mãe, '') + '|^' + this.monthsShort(mãe, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // testa a regex
            E se (
                rigoroso &&
                formato === 'MMMM' &&
                this._longMonthsParse[i].test(monthName)
            ) {
                retorno eu;
            } senão se (
                rigoroso &&
                formato === 'MMM' &&
                this._shortMonthsParse[i].test(monthName)
            ) {
                retorno eu;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                retorno eu;
            }
        }
    }

    // MOMENTOS

    function setMonth(mãe, valor) {
        var diaDoMês;

        if (!mãe.isValid()) {
            // Sem operação
            voltar mãe;
        }

        if (tipo de valor === 'string') {
            if (/^\d+$/.test(valor)) {
                valor = toInt(valor);
            } senão {
                valor = mom.localeData().monthsParse(valor);
                // TODO: Outra falha silenciosa?
                if (!isNúmero(valor)) {
                    voltar mãe;
                }
            }
        }

        diaDoMês = Math.min(mãe.data(), diasInMês(mãe.ano(), valor));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        voltar mãe;
    }

    function getSetMonth(valor) {
        if (valor != null) {
            setMonth(this, valor);
            hooks.updateOffset(this, true);
            devolva isso;
        } senão {
            return get(this, 'Mês');
        }
    }

    function getDiasEmMês() {
        return diasInMês(este.ano(), este.mês());
    }

    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computaMonthsParse.call(this);
            }
            if (éEstrita) {
                return this._monthsShortStrictRegex;
            } senão {
                retorne this._monthsShortRegex;
            }
        } senão {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            retornar this._monthsShortStrictRegex && isStrict
                ? this._monthsShortStrictRegex
                : this._monthsShortRegex;
        }
    }

    function monthRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computaMonthsParse.call(this);
            }
            if (éEstrita) {
                retorne this._monthsStrictRegex;
            } senão {
                retorne this._monthsRegex;
            }
        } senão {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            retornar this._monthsStrictRegex && isStrict
                ? this._monthsStrictRegex
                : this._monthsRegex;
        }
    }

    function computaMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [],
            peças longas = [],
            peças mistas = [],
            eu,
            mamãe;
        for (i = 0; i < 12; i++) {
            // faz a regex se ainda não a tivermos
            mãe = criarUTC([2000,i]);
            shortPieces.push(este.mesesShort(mãe, ''));
            longPieces.push(este.meses(mãe, ''));
            mixedPieces.push(este.meses(mãe, ''));
            mixedPieces.push(este.mesesShort(mãe, ''));
        }
        // A classificação garante se um mês (ou abbr) é um prefixo de outro
        // corresponderá à peça mais longa.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'eu'
        );
        this._monthsShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'eu'
        );
    }

    // FORMATAÇÃO

    addFormatToken('Y', 0, 0, function() {
        var y = este.ano();
        retornar y <= 9999 ? zeroFill(y, 4): '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function() {
        return this.year() % 100;
    });

    addFormatToken(0, ['AAAA', 4], 0, 'ano');
    addFormatToken(0, ['AAAA', 5], 0, 'ano');
    addFormatToken(0, ['AAAAAA', 6, verdadeiro], 0, 'ano');

    // APELIDO

    addUnitAlias('ano', 's');

    // PRIORIDADES

    addUnitPriority('ano', 1);

    // ANALISANDO

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('AAAA', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['AAAA', 'AAAAAA'], ANO);
    addParseToken('AAAA', function (entrada, array) {
        matriz[ANO] =
            entrada.comprimento === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (entrada, array) {
        array[ANO] = ganchos.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (entrada, array) {
        array[ANO] = parseInt(entrada, 10);
    });

    // AJUDANTES

    função diasEmAno(ano) {
        return isLeapYear(ano) ? 366: 365;
    }

    // GANCHOS

    hooks.parseTwoDigitYear = function (entrada) {
        return toInt(entrada) + (toInt(entrada) > 68 ? 1900 : 2000);
    };

    // MOMENTOS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
        return isLeapYear(este.ano());
    }

    function createDate(y, m, d, h, M, s, ms) {
        // não pode simplesmente aplicar() para criar uma data:
        // https://stackoverflow.com/q/181348
        var data;
        // o construtor de data remapeia os anos 0-99 para 1900-1999
        if (y < 100 && y >= 0) {
            // preserva os anos bissextos usando um ciclo completo de 400 anos, depois reinicia
            data = new Data(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                data.setFullYear(y);
            }
        } senão {
            data = new Data(y, m, d, h, M, s, ms);
        }

        data de retorno;
    }

    function createUTCDate(y) {
        var data, argumentos;
        // a função Date.UTC remapeia os anos 0-99 para 1900-1999
        if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(argumentos);
            // preserva os anos bissextos usando um ciclo completo de 400 anos, depois reinicia
            args[0] = y + 400;
            data = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                data.setUTCFullYear(y);
            }
        } senão {
            data = new Date(Date.UTC.apply(null, arguments));
        }

        data de retorno;
    }

    // início da primeira semana - início do ano
    function firstWeekOffset(ano, dow, doy) {
        var // dia da primeira semana -- que janeiro é sempre na primeira semana (4 para iso, 1 para outro)
            fwd = 7 + dow - doy,
            // primeiro dia da semana dia da semana local -- qual dia da semana local é fwd
            fwdlw = (7 + createUTCDate(ano, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(ano, semana, dia da semana, dow, doy) {
        var localWeekday = (7 + dia da semana - dow) % 7,
            WeekOffset = firstWeekOffset(ano, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resAno,
            resDiaDoAno;

        if (diaDoAno <= 0) {
            resAno = ano - 1;
            resDayOfYear = diasInYear(resYear) + diaDoAno;
        } else if (diaDoAno > diasNoAno(ano)) {
            resAno = ano + 1;
            resDiaDoAno = diaDoAno - diasEmAno(ano);
        } senão {
            resAno = ano;
            resDiaDoAno = diaDoAno;
        }

        Retorna {
            ano: resYear,
            diaDoAno: resDiaDoAno,
        };
    }

    function semanaDoAno(mãe, mãe, mãe) {
        var semanaOffset = firstWeekOffset(mãe.ano(), dow, doy),
            semana = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resAno;

        if (semana < 1) {
            resAno = mãe.ano() - 1;
            resWeek = semana + semanasInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mãe.ano(), dow, doy)) {
            resWeek = semana - semanasInYear(mãe.ano(), dow, doy);
            resAno = mãe.ano() + 1;
        } senão {
            resAno = mãe.ano();
            resSemana = semana;
        }

        Retorna {
            semana: resWeek,
            ano: resYear,
        };
    }

    function semanasInYear(ano, dow, doy) {
        var WeekOffset = firstWeekOffset(ano, dow, doy),
            WeekOffsetNext = firstWeekOffset(ano + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATAÇÃO

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // APELIDO

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORIDADES

    addUnitPriority('semana', 5);
    addUnitPriority('isoWeek', 5);

    // ANALISANDO

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(
        ['w', 'ww', 'W', 'WW'],
        function (entrada, semana, configuração, token) {
            semana[token.substr(0, 1)] = toInt(entrada);
        }
    );

    // AJUDANTES

    // LOCAIS

    function localeWeek(mãe) {
        return weekOfYear(mãe, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow: 0, // Domingo é o primeiro dia da semana.
        doy: 6, // A semana que contém 6 de janeiro é a primeira semana do ano.
    };

    function localeFirstDayOfWeek() {
        retorne this._week.dow;
    }

    function localeFirstDayOfYear() {
        return this._week.doy;
    }

    // MOMENTOS

    function getSetWeek(entrada) {
        var semana = this.localeData().week(this);
        entrada de retorno == null ? semana : this.add((entrada - semana) * 7, 'd');
    }

    function getSetISOWeek(entrada) {
        var semana = semanaDoAno(este, 1, 4).semana;
        entrada de retorno == null ? semana : this.add((entrada - semana) * 7, 'd');
    }

    // FORMATAÇÃO

    addFormatToken('d', 0, 'fazer', 'dia');

    addFormatToken('dd', 0, 0, function (formato) {
        return this.localeData().weekdaysMin(this, formato);
    });

    addFormatToken('ddd', 0, 0, function (formato) {
        return this.localeData().weekdaysShort(this, formato);
    });

    addFormatToken('dddd', 0, 0, function (formato) {
        return this.localeData().weekdays(this, formato);
    });

    addFormatToken('e', 0, 0, 'dia da semana');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // APELIDO

    addUnitAlias('dia', 'd');
    addUnitAlias('dia da semana', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORIDADE
    addUnitPriority('dia', 11);
    addUnitPriority('dia da semana', 11);
    addUnitPriority('isoWeekday', 11);

    // ANALISANDO

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], função (entrada, semana, configuração, token) {
        var dia da semana = config._locale.weekdaysParse(input, token, config._strict);
        // se não obtivermos um nome de dia da semana, marque a data como inválida
        if (dia da semana != null) {
            semana.d = dia da semana;
        } senão {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', ​​'E'], função (entrada, semana, configuração, token) {
        semana[token] = toInt(entrada);
    });

    // AJUDANTES

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            entrada de retorno;
        }

        if (!isNaN(entrada)) {
            return parseInt(entrada, 10);
        }

        entrada = locale.weekdaysParse(input);
        if (tipo de entrada === 'número') {
            entrada de retorno;
        }

        retornar nulo;
    }

    function parseIsoWeekday(entrada, localidade) {
        if (tipo de entrada === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(entrada) ? null : entrada;
    }

    // LOCAIS
    function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays =
            'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        defaultWeekdaysRegex = matchWord,
        defaultWeekdaysShortRegex = matchWord,
        defaultWeekdaysMinRegex = matchWord;

    function localeWeekdays(m, formato) {
        var dias da semana = isArray(this._weekdays)
            ? this._weekdays
            : this._weekdays[
                  m && m !== true && this._weekdays.isFormat.test(format)
                      ? 'formato'
                      : 'estar sozinho'
              ];
        return m === verdadeiro
            ? shiftWeekdays(dias da semana, this._week.dow)
            : m
            ? dias da semana[m.dia()]
            : dias da semana;
    }

    function localeWeekdaysShort(m) {
        return m === verdadeiro
            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : m
            ? this._weekdaysShort[m.day()]
            : this._weekdaysShort;
    }

    function localeWeekdaysMin(m) {
        return m === verdadeiro
            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : m
            ? this._weekdaysMin[m.day()]
            : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var eu,
            ii,
            mamãe,
            llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            para (i = 0; i < 7; ++i) {
                mãe = criarUTC([2000, 1]).dia(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(
                    mamãe,
                    ''
                ).toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(
                    mamãe,
                    ''
                ).toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mãe, '').toLocaleLowerCase();
            }
        }

        se (estrito) {
            if (formato === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii: nulo;
            } else if (formato === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii: nulo;
            } senão {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii: nulo;
            }
        } senão {
            if (formato === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    retorno ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    retorno ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii: nulo;
            } else if (formato === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    retorno ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    retorno ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii: nulo;
            } senão {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    retorno ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    retorno ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii: nulo;
            }
        }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mãe, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // faz a regex se ainda não a tivermos

            mãe = criarUTC([2000, 1]).dia(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdays(mãe, '').replace('.', '\\.?') + '$',
                    'eu'
                );
                this._shortWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysShort(mãe, '').replace('.', '\\.?') + '$',
                    'eu'
                );
                this._minWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysMin(mãe, '').replace('.', '\\.?') + '$',
                    'eu'
                );
            }
            if (!this._weekdaysParse[i]) {
                regex =
                    '^' +
                    this.weekdays(mãe, '') +
                    '|^' +
                    this.weekdaysShort(mãe, '') +
                    '|^' +
                    this.weekdaysMin(mãe, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // testa a regex
            E se (
                rigoroso &&
                formato === 'dddd' &&
                this._fullWeekdaysParse[i].test(weekdayName)
            ) {
                retorno eu;
            } senão se (
                rigoroso &&
                formato === 'ddd' &&
                this._shortWeekdaysParse[i].test(weekdayName)
            ) {
                retorno eu;
            } senão se (
                rigoroso &&
                formato === 'dd' &&
                this._minWeekdaysParse[i].test(weekdayName)
            ) {
                retorno eu;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                retorno eu;
            }
        }
    }

    // MOMENTOS

    function getSetDayOfWeek(entrada) {
        if (!this.isValid()) {
            retorno de entrada!= null ? este: NaN;
        }
        var dia = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - dia, 'd');
        } senão {
            dia de retorno;
        }
    }

    function getSetLocaleDayOfWeek(entrada) {
        if (!this.isValid()) {
            retorno de entrada!= null ? este: NaN;
        }
        var dia da semana = (this.day() + 7 - this.localeData()._week.dow) % 7;
        entrada de retorno == null ? dia da semana : this.add(input - dia da semana, 'd');
    }

    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            retorno de entrada!= null ? este: NaN;
        }

        // se comporta da mesma forma que momento#dia, exceto
        // como getter, retorna 7 em vez de 0 (intervalo 1-7 em vez de 0-6)
        // como setter, domingo deve pertencer à semana anterior.

        if (input != null) {
            var dia da semana = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } senão {
            return this.day() || 7;
        }
    }

    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computaWeekdaysParse.call(this);
            }
            if (éEstrita) {
                return this._weekdaysStrictRegex;
            } senão {
                return this._weekdaysRegex;
            }
        } senão {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            retornar this._weekdaysStrictRegex && isStrict
                ? this._weekdaysStrictRegex
                : this._weekdaysRegex;
        }
    }

    function dias da semanaShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computaWeekdaysParse.call(this);
            }
            if (éEstrita) {
                return this._weekdaysShortStrictRegex;
            } senão {
                return this._weekdaysShortRegex;
            }
        } senão {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            retornar this._weekdaysShortStrictRegex && isStrict
                ? this._weekdaysShortStrictRegex
                : this._weekdaysShortRegex;
        }
    }

    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computaWeekdaysParse.call(this);
            }
            if (éEstrita) {
                return this._weekdaysMinStrictRegex;
            } senão {
                return this._weekdaysMinRegex;
            }
        } senão {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            retornar this._weekdaysMinStrictRegex && isStrict
                ? this._weekdaysMinStrictRegex
                : this._weekdaysMinRegex;
        }
    }

    function computaWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPeças = [],
            peças curtas = [],
            peças longas = [],
            peças mistas = [],
            eu,
            mamãe,
            minp,
            curto,
            longp;
        for (i = 0; i < 7; i++) {
            // faz a regex se ainda não a tivermos
            mãe = criarUTC([2000, 1]).dia(i);
            minp = regexEscape(this.weekdaysMin(mãe, ''));
            shortp = regexEscape(this.weekdaysShort(mãe, ''));
            longp = regexEscape(this.weekdays(mãe, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // A classificação garante se um dia da semana (ou abbr) é um prefixo de outro
        // corresponderá à peça mais longa.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'eu'
        );
        this._weekdaysShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'eu'
        );
        this._weekdaysMinStrictRegex = new RegExp(
            '^(' + minPieces.join('|') + ')',
            'eu'
        );
    }

    // FORMATAÇÃO

    função hFormato() {
        return this.hours() % 12 || 12;
    }

    function kFormato() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hora');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function() {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function() {
        Retorna (
            '' +
            hFormat.apply(this) +
            zeroFill(este.minutos(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    addFormatToken('Hmm', 0, 0, function() {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function() {
        Retorna (
            '' +
            this.horas() +
            zeroFill(este.minutos(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    function meridiem(token, minúscula) {
        addFormatToken(token, 0, 0, function() {
            return this.localeData().meridiem(
                this.horas(),
                this.minutos(),
                minúscula
            );
        });
    }

    meridiem('a', verdadeiro);
    meridiem('A', false);

    // APELIDO

    addUnitAlias('hora', 'h');

    // PRIORIDADE
    addUnitPriority('hora', 13);

    // ANALISANDO

    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HORA);
    addParseToken(['k', 'kk'], function (entrada, array, config) {
        var kEntrada = toInt(entrada);
        array[HORA] = kEntrada === 24 ? 0 : kEntrada;
    });
    addParseToken(['a', 'A'], function (entrada, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (entrada, array, config) {
        array[HORA] = toInt(entrada);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (entrada, array, config) {
        var pos = entrada.comprimento - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (entrada, array, config) {
        var pos1 = input.length - 4,
            pos2 = entrada.comprimento - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (entrada, array, config) {
        var pos = entrada.comprimento - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (entrada, array, config) {
        var pos1 = input.length - 4,
            pos2 = entrada.comprimento - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCAIS

    function localeIsPM(entrada) {
        // IE8 Quirks Mode e IE7 Standards Mode não permitem acessar strings como arrays
        // Usar charAt deve ser mais compatível.
        return (entrada + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
        // Definir a hora deve manter a hora, porque o usuário explicitamente
        // especificou qual hora eles querem. Então, tentando manter a mesma hora (em
        // um novo fuso horário) faz sentido. A adição/subtração de horas não segue
        // Esta regra.
        getSetHour = makeGetSet('Horas', true);

    function localeMeridiem(horas, minutos, isLower) {
        if (horas > 11) {
            return isLower ? 'pm': 'PM';
        } senão {
            return isLower ? 'sou': 'sou';
        }
    }

    var baseConfig = {
        calendário: defaultCalendar,
        LongDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        temporelativo: defaultRelativeTime,

        meses: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        semana: defaultLocaleWeek,

        dias da semana: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        WeekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse,
    };

    // armazenamento interno para arquivos de configuração de localidade
    var localidades = {},
        localeFamílias = {},
        globalLocale;

    function commonPrefix(arr1,arr2) {
        var eu,
            minl = Math.min(arr1.comprimento, arr2.comprimento);
        for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
                retorno eu;
            }
        }
        retorno mínimo;
    }

    function normalizeLocale(chave) {
        chave de retorno ? key.toLowerCase().replace('_', '-') : key;
    }

    // escolhe a localidade do array
    // tente ['en-au', 'en-gb'] como 'en-au', 'en-gb', 'en', como em percorrer a lista tentando cada
    // substring do mais específico para o menos, mas move para o próximo item do array se for uma variante mais específica que a raiz atual
    function escolhaLocal(nomes) {
        var i = 0,
            j,
            próximo,
            localidade,
            dividir;

        while (i < nomes.comprimento) {
            split = normalizeLocale(nomes[i]).split('-');
            j = split.length;
            next = normalizeLocale(nomes[i + 1]);
            próximo = próximo? next.split('-'): null;
            enquanto (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (localidade) {
                    retornar localidade;
                }
                E se (
                    próximo &&
                    next.length >= j &&
                    commonPrefix(dividir, próximo) >= j - 1
                ) {
                    //o próximo item do array é melhor do que uma substring mais rasa deste
                    parar;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function isLocaleNameSane(name) {
        // Impede nomes que se parecem com caminhos do sistema de arquivos, ou seja, contêm '/' ou '\'
        return name.match('^[^/\\\\]*$') != null;
    }

    function loadLocale(nome) {
        var oldLocale = null,
            aliasRequire;
        // TODO: Encontre uma maneira melhor de registrar e carregar todas as localidades no Node
        E se (
            locales[name] === indefinido &&
            módulo typeof !== 'undefined' &&
            módulo &&
            module.exports &&
            isLocaleNameSane(name)
        ) {
            tentar {
                oldLocale = globalLocale._abbr;
                aliasedRequire = exigir;
                aliasedRequire('./locale/' + nome);
                getSetGlobalLocale(oldLocale);
            } pegar (e) {
                // marca como não encontrado para evitar a repetição de arquivos caros exigem chamada causando alta CPU
                // ao tentar encontrar en-US, en_US, en-us para cada chamada de formato
                locales[nome] = null; // null significa não encontrado
            }
        }
        return locales[nome];
    }

    // Esta função carregará a localidade e, em seguida, definirá a localidade global. Se
    // nenhum argumento é passado, ele simplesmente retornará o valor global atual
    // chave de localidade.
    function getSetGlobalLocale(chave, valores) {
        var dados;
        if (chave) {
            if (éIndefinido(valores)) {
                dados = getLocale(chave);
            } senão {
                dados = defineLocale(chave, valores);
            }

            se (dados) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = dados;
            } senão {
                if (typeof console !== 'undefined' && console.warn) {
                    //avisa o usuário se os argumentos são passados, mas a localidade não pode ser definida
                    console.warn(
                        'Locale ' + chave + ' não encontrado. Você esqueceu de carregá-lo?
                    );
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale(nome, configuração) {
        if (config !== null) {
            var localidade,
                parentConfig = baseConfig;
            config.abbr = nome;
            if (locales[nome] != null) {
                deprecateSimple(
                    'defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) para alterar ' +
                        'uma localidade existente. moment.defineLocale(localeName, ' +
                        'config) deve ser usado apenas para criar uma nova localidade ' +
                        'Veja http://momentjs.com/guides/#/warnings/define-locale/ para mais informações.'
                );
                parentConfig = locales[nome]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } senão {
                    locale = loadLocale(config.parentLocale);
                    if (localidade != null) {
                        parentConfig = locale._config;
                    } senão {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamílias[config.parentLocale].push({
                            nome nome,
                            configuração: configuração,
                        });
                        retornar nulo;
                    }
                }
            }
            locales[nome] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamílias[nome]) {
                localeFamílias[nome].forEach(função (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // retrocompatibilidade por enquanto: também defina a localidade
            // certifique-se de definir a localidade APÓS todas as localidades filhas terem sido
            // criado, então não terminaremos com o locale filho definido.
            getSetGlobalLocale(nome);

            return locales[nome];
        } senão {
            // útil para testes
            delete locales[nome];
            retornar nulo;
        }
    }

    function updateLocale(nome, configuração) {
        if (config!= null) {
            var localidade,
                tmpLocale,
                parentConfig = baseConfig;

            if (locales[name] != null && locales[name].parentLocale != null) {
                // Atualiza a localidade filha existente no local para evitar vazamentos de memória
                locales[name].set(mergeConfigs(locales[name]._config, config));
            } senão {
                // MERGE
                tmpLocale = loadLocale(nome);
                if (tmpLocale != null) {
                    parentConfig = tmpLocale._config;
                }
                config = mergeConfigs(parentConfig, config);
                if (tmpLocale == null) {
                    // updateLocale é chamado para criar uma nova localidade
                    // Configura abbr para que tenha um nome (getters return
                    // indefinido caso contrário).
                    config.abbr = nome;
                }
                localidade = new Locale(config);
                locale.parentLocale = locales[nome];
                localidades[nome] = localidade;
            }

            // retrocompatibilidade por enquanto: também defina a localidade
            getSetGlobalLocale(nome);
        } senão {
            // passa null para config para desatualizar, útil para testes
            if (locales[nome] != null) {
                if (locales[nome].parentLocale != null) {
                    locales[nome] = locales[nome].parentLocale;
                    if (nome === getSetGlobalLocale()) {
                        getSetGlobalLocale(nome);
                    }
                } else if (locales[nome] != null) {
                    delete locales[nome];
                }
            }
        }
        return locales[nome];
    }

    // retorna dados de localidade
    function getLocale(chave) {
        var localidade;

        if (chave && chave._locale && chave._locale._abbr) {
            chave = chave._locale._abbr;
        }

        if (!chave) {
            return globalLocale;
        }

        if (!isArray(chave)) {
            //curto-circuito todo o resto
            localidade = loadLocale(chave);
            if (localidade) {
                retornar localidade;
            }
            chave = [chave];
        }

        return escolhaLocal(chave);
    }

    function listaLocales() {
        chaves de retorno (localidades);
    }

    função checkOverflow(m) {
        var estouro,
            a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            estouro =
                a[MÊS] < 0 || a[MÊS] > 11
                    ? MÊS
                    : a[DATA] < 1 || a[DATA] > diasEmMês(a[ANO], a[MÊS])
                    ? ENCONTRO
                    : a[HORA] < 0 ||
                      a[HORA] > 24 ||
                      (a[HORA] === 24 &&
                          (a[MINUTO] !== 0 ||
                              a[SEGUNDA] !== 0 ||
                              a[MILISEGUNDO] !== 0))
                    ? HORA
                    : a[MINUTO] < 0 || a[MINUTO] > 59
                    ? MINUTO
                    : a[SEGUNDA] < 0 || a[SEGUNDA] > 59
                    ? SEGUNDO
                    : a[MILISEGUNDO] < 0 || a[MILISEGUNDO] > 999
                    ? MILISEGUNDO
                    : -1;

            E se (
                getParsingFlags(m)._overflowDayOfYear &&
                (estouro < ANO || estouro > DATA)
            ) {
                estouro = DATA;
            }
            if (getParsingFlags(m)._overflowWeeks && estouro === -1) {
                estouro = SEMANA;
            }
            if (getParsingFlags(m)._overflowWeekday && estouro === -1) {
                estouro = DIA DA SEMANA;
            }

            getParsingFlags(m).overflow = estouro;
        }

        retornar m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 ou 0000-W00-0 + T + 00 ou 00:00 ou 00:00:00 ou 00:00:00.000 + +00:00 ou +0000 ou +00)
    var estendidoIsoRegex =
            /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\ d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[. ,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        basicIsoRegex =
            /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d |\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+ )?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
        isoDatas = [
            ['AAAA-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
            ['AAAA-MM-DD', /\d{4}-\d\d-\d\d/],
            ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
            ['AAAA-DDD', /\d{4}-\d{3}/],
            ['AAAA-MM', /\d{4}-\d\d/, falso],
            ['AAAAAAMMDD', /[+-]\d{10}/],
            ['AAAAMMDD', /\d{8}/],
            ['GGGG[W]WWE', /\d{4}W\d{3}/],
            ['GGGG[W]WW', /\d{4}W\d{2}/, false],
            ['AAAADDD', /\d{7}/],
            ['AAAAMM', /\d{6}/, falso],
            ['AAAA', /\d{4}/, falso],
        ],
        // formatos de hora iso e regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
            ['HH:mm:ss', /\d\d:\d\d:\d\d/],
            ['HH:mm', /\d\d:\d\d/],
            ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
            ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
            ['HHmmss', /\d\d\d\d\d\d/],
            ['HHmm', /\d\d\d\d/],
            ['HH', /\d\d/],
        ],
        aspNetJsonRegex = /^\/?Data\((-?\d+)/i,
        // RFC 2822 regex: Para obter detalhes, consulte https://tools.ietf.org/html/rfc2822#section-3.3
        rfc2822 =
            /^(?:(Seg|Ter|Qua|Qui|Sex|Sáb|Dom),?\s)?(\d{1,2})\s(Jan|Fev|Mar|Abr|Mai|Jun| Jul|Ago|Set|Out|Nov|Dez)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))? \s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
        obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60,
        };

    // data do formato iso
    function configFromISO(config) {
        var eu,
            eu,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            permitirTempo,
            Formato de data,
            formato de hora,
            tzFormato,
            isoDatesLen = isoDates.length,
            isoTimesLen = isoTimes.length;

        if (corresponder) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDatesLen; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    parar;
                }
            }
            if (dataFormato == null) {
                config._isValid = false;
                Retorna;
            }
            if (correspondência[3]) {
                for (i = 0, l = isoTimesLen; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] deve ser 'T' ou espaço
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        parar;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    Retorna;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                Retorna;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormato = 'Z';
                } senão {
                    config._isValid = false;
                    Retorna;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } senão {
            config._isValid = false;
        }
    }

    função extractFromRFC2822Strings(
        anoStr,
        mêsStr,
        diaStr,
        horaStr,
        minutoStr,
        segundaStr
    ) {
        var resultado = [
            unruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(horaStr, 10),
            parseInt(minutoStr, 10),
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        retorno resultado;
    }

    function unruncateYear(yearStr) {
        var ano = parseInt(yearStr, 10);
        if (ano <= 49) {
            retornar 2000 + ano;
        } else if (ano <= 999) {
            retornar 1900 + ano;
        }
        ano de retorno;
    }

    função pré-processamentoRFC2822(s) {
        // Remove comentários e espaços em branco dobráveis ​​e substitui vários espaços por um único espaço
        retorno s
            .replace(/\([^)]*\)|[\n\t]/g, ' ')
            .replace(/(\s\s+)/g, ' ')
            .replace(/^\s\s*/, '')
            .replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Substitua o objeto Vanilla JS Date por uma verificação independente de dia da semana.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                dia da semanaAtual = new Data(
                    analisadoEntrada[0],
                    analisadoEntrada[1],
                    entrada analisada[2]
                ).getDia();
            if (daydayForneced !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                retorna falso;
            }
        }
        retorne verdadeiro;
    }

    function calcularOffset(obsOffset, militaryOffset, numOffset) {
        if (obsDeslocamento) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // o único tz militar permitido é Z
            retornar 0;
        } senão {
            var hm = parseInt(numOffset, 10),
                m = hm % 100,
                h = (hm - m)/100;
            retornar h * 60 + m;
        }
    }

    // data e hora do formato ref 2822
    função configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)),
            analisadoArray;
        if (corresponder) {
            parsedArray = extractFromRFC2822Strings(
                partida[4],
                partida[3],
                partida[2],
                partida[5],
                partida[6],
                partida[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
                Retorna;
            }

            config._a = analisadoArray;
            config._tzm = calcularOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } senão {
            config._isValid = false;
        }
    }

    // data de 1) ASP.NET, 2) ISO, 3) formatos RFC 2822 ou 4) fallback opcional se a análise não for rigorosa
    function configFromString(config) {
        var correspondido = aspNetJsonRegex.exec(config._i);
        if (correspondeu!== null) {
            config._d = new Date(+matched[1]);
            Retorna;
        }

        configFromISO(config);
        if (config._isValid === false) {
            excluir config._isValid;
        } senão {
            Retorna;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            excluir config._isValid;
        } senão {
            Retorna;
        }

        if (config._strict) {
            config._isValid = false;
        } senão {
            // Tentativa final, use Input Fallback
            hooks.createFromInputFallback(config);
        }
    }

    hooks.createFromInputFallback = preter(
        'valor fornecido não está em um formato RFC2822 ou ISO reconhecido. construção do momento volta para js Date(), ' +
            'que não é confiável em todos os navegadores e versões. Os formatos de data não RFC2822/ISO são ' +
            'desanimado. Consulte http://momentjs.com/guides/#/warnings/js-date/ para obter mais informações.',
        função (configuração) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Escolha o primeiro definido de dois ou três argumentos.
    função padrão (a, b, c) {
        if (a != null) {
            retornar um;
        }
        if (b!= null) {
            retornar b;
        }
        retornar c;
    }

    function currentDateArray(config) {
        // hooks é na verdade o objeto de momento exportado
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            Retorna [
                nowValue.getUTCFullYear(),
                nowValue.getUTCMonth(),
                nowValue.getUTCDate(),
            ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // converte um array em uma data.
    // o array deve espelhar os parâmetros abaixo
    // nota: todos os valores após o ano são opcionais e serão padronizados para o menor valor possível.
    // [ano, mês, dia, hora, minuto, segundo, milissegundo]
    function configFromArray(config) {
        var eu,
            encontro,
            entrada = [],
            data atual,
            esperadoDia da semana,
            anoParaUsar;

        if (config._d) {
            Retorna;
        }

        currentDate = currentDateArray(config);

        //computa o dia do ano a partir de semanas e dias da semana
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //se o dia do ano estiver definido, descubra qual é
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            E se (
                config._dayOfYear > daysInYear(yearToUse) ||
                config._dayOfYear === 0
            ) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            data = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATA] = data.getUTCDate();
        }

        // Padrão para a data atual.
        // * se nenhum ano, mês, dia do mês for fornecido, padrão para hoje
        // * se o dia do mês for fornecido, mês e ano padrão
        // * se o mês for fornecido, padrão apenas o ano
        // * se o ano for fornecido, não padronize nada
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zera o que não foi padronizado, incluindo o tempo
        for (; i < 7; i++) {
            config._a[i] = input[i] =
                config._a[i] == null ? (i === 2 ? 1 : 0): config._a[i];
        }

        // Verifique para 24:00:00.000
        E se (
            config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILISECOND] === 0
        ) {
            config._nextDay = true;
            config._a[HORA] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(
            nulo,
            entrada
        );
        esperadoWeekday = config._useUTC
            ? config._d.getUTCDay()
            : config._d.getDay();

        // Aplicar deslocamento de fuso horário da entrada. O utcOffset real pode ser alterado
        // com parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HORA] = 24;
        }

        // verifica se há incompatibilidade de dia da semana
        E se (
            config._w &&
            typeof config._w.d !== 'undefined' &&
            config._w.d !== esperadoDia da semana
        ) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

        w = config._w;
        if (w.GG != null || wW != null || wE != null) {
            baixa = 1;
            doa = 4;

            // TODO: Precisamos pegar o isoWeekYear atual, mas isso depende
            // como interpretamos agora (local, utc, offset fixo). Então crie
            // uma versão agora da configuração atual (pegue os sinalizadores local/utc/offset e
            // Crie agora).
            semanaAno = defaults(
                w.GG,
                config._a[ANO],
                semanaDoAno(criarLocal(), 1, 4).ano
            );
            semana = defaults(wW, 1);
            dia da semana = defaults(wE, 1);
            if (dia da semana < 1 || dia da semana > 7) {
                weekdayOverflow = true;
            }
        } senão {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Padrão para a semana atual.
            semana = defaults(ww, curWeek.week);

            if (wd != null) {
                // dia da semana -- números de dias baixos são considerados na próxima semana
                dia da semana = wd;
                if (dia da semana < 0 || dia da semana > 6) {
                    weekdayOverflow = true;
                }
            } senão if (nós != null) {
                // dia da semana local -- a contagem começa no início da semana
                dia da semana = nós + dow;
                if (nós < 0 || nós > 6) {
                    weekdayOverflow = true;
                }
            } senão {
                // padrão para o início da semana
                dia da semana = baixa;
            }
        }
        if (semana < 1 || semana > semanasInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } senão {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[ANO] = temp.ano;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constante que se refere ao padrão ISO
    ganchos.ISO_8601 = function () {};

    // constante que se refere ao formulário RFC 2822
    ganchos.RFC_2822 = função () {};

    // data da string e formatação da string
    function configFromStringAndFormat(config) {
        // TODO: Mova isso para outra parte do fluxo de criação para evitar deps circulares
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            Retorna;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            Retorna;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // Este array é usado para fazer uma Data, seja com `new Date` ou `Date.UTC`
        var string = '' + config._i,
            eu,
            analisadoEntrada,
            fichas,
            símbolo,
            ignorado,
            stringLength = string.length,
            totalParsedInputLength = 0,
            era,
            tokenLen;

        fichas =
            expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens.length;
        for (i = 0; i < tokenLen; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                [])[0];
            if (entrada analisada) {
                ignorado = string.substr(0, string.indexOf(parsedInput));
                if (pulado.comprimento > 0) {
                    getParsingFlags(config).unusedInput.push(ignorado);
                }
                string = string.fatia(
                    string.indexOf(parsedInput) + parsedInput.length
                );
                totalParsedInputLength += parsedInput.length;
            }
            // não analisa se não for um token conhecido
            if (formatTokenFunctions[token]) {
                if (entrada analisada) {
                    getParsingFlags(config).empty = false;
                } senão {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // adiciona o comprimento de entrada não analisado restante à string
        getParsingFlags(config).charsLeftOver =
            stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // limpa o sinalizador _12h se a hora for <= 12
        E se (
            config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0
        ) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // trata do meridiano
        config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HORA],
            config._meridiem
        );

        // manipula a era
        era = getParsingFlags(config).era;
        if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }

        configFromArray(config);
        checkOverflow(config);
    }

    function meridiemFixWrap(local, hora, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nada para fazer
            hora de retorno;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hora, meridiem);
        } else if (locale.isPM != null) {
            // Cair pra trás
            isPm = locale.isPM(meridiem);
            if (isPm && hora < 12) {
                hora += 12;
            }
            if (!isPm && hora === 12) {
                hora = 0;
            }
            hora de retorno;
        } senão {
            // isso não deveria acontecer
            hora de retorno;
        }
    }

    // data da string e array de strings de formato
    function configFromStringAndArray(config) {
        var tempConfig,
            melhor momento,
            scoreToBeat,
            eu,
            pontuação atual,
            validFormatFound,
            bestFormatIsValid = false,
            configfLen = config._f.length;

        if (configfLen === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Data(NaN);
            Retorna;
        }

        for (i = 0; i < configfLen; i++) {
            pontuação atual = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (isValid(tempConfig)) {
                validFormatFound = true;
            }

            // se houver alguma entrada que não foi analisada adiciona uma penalidade para esse formato
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //ou tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (!bestFormatIsValid) {
                E se (
                    scoreToBeat == null ||
                    currentScore < scoreToBeat ||
                    validFormatFound
                ) {
                    scoreToBeat = currentScore;
                    melhorMomento = tempConfig;
                    if (validFormatFound) {
                        bestFormatIsValid = true;
                    }
                }
            } senão {
                if (currentScore < scoreToBeat) {
                    scoreToBeat = currentScore;
                    melhorMomento = tempConfig;
                }
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            Retorna;
        }

        var i = normalizeObjectUnits(config._i),
            dayOrDate = i.day === indefinido ? i.data : i.dia;
        config._a = map(
            [i.ano, i.mês, diaOrDate, i.hora, i.minuto, i.segundo, i.milissegundo],
            função (obj) {
                return obj && parseInt(obj, 10);
            }
        );

        configFromArray(config);
    }

    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adicionar é inteligente o suficiente em torno do horário de verão
            res.add(1, 'd');
            res._nextDay = indefinido;
        }

        retorno res;
    }

    function prepareConfig(config) {
        var entrada = config._i,
            formato = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (entrada === null || (formato === indefinido && entrada === '')) {
            return createInvalid({ nullInput: true });
        }

        if (tipo de entrada === 'string') {
            config._i = entrada = config._locale.preparse(entrada);
        }

        if (éMomento(entrada)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = entrada;
        } else if (isArray(formato)) {
            configFromStringAndArray(config);
        } else if (formato) {
            configFromStringAndFormat(config);
        } senão {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        configuração de retorno;
    }

    function configFromInput(config) {
        var entrada = config._i;
        if (éIndefinido(entrada)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (tipo de entrada === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // a partir de milissegundos
            config._d = new Data(entrada);
        } senão {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};

        if (formato === verdadeiro || formato === falso) {
            estrito = formato;
            formato = indefinido;
        }

        if (local === true || local === false) {
            estrito = localidade;
            localidade = indefinido;
        }

        E se (
            (isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)
        ) {
            entrada = indefinido;
        }
        // a construção do objeto deve ser feita desta forma.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = localidade;
        c._i = entrada;
        c._f = formato;
        c._strict = estrito;

        return createFromConfig(c);
    }

    function createLocal(entrada, formato, localidade, estrito) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = obsoleto(
            'moment().min está obsoleto, use moment.max em vez disso. http://momentjs.com/guides/#/warnings/min-max/',
            função () {
                var outro = createLocal.apply(null, argumentos);
                if (this.isValid() && other.isValid()) {
                    retornar outro < this ? este: outro;
                } senão {
                    return criarInválido();
                }
            }
        ),
        prototypeMax = obsoleto(
            'moment().max está obsoleto, use moment.min em vez disso. http://momentjs.com/guides/#/warnings/min-max/',
            função () {
                var outro = createLocal.apply(null, argumentos);
                if (this.isValid() && other.isValid()) {
                    retornar outro > isso ? este: outro;
                } senão {
                    return criarInválido();
                }
            }
        );

    // Escolhe um momento m de momentos para que m[fn](other) seja verdadeiro para todos
    // outro. Isso depende da função fn ser transitiva.
    //
    // momentos devem ser um array de objetos moment ou um array, cujo
    // o primeiro elemento é um array de objetos moment.
    function pickBy(fn, momentos) {
        var res, i;
        if (momentos.comprimento === 1 && isArray(momentos[0])) {
            momentos = momentos[0];
        }
        if (!momentos.comprimento) {
            return criarLocal();
        }
        res = momentos[0];
        for (i = 1; i < momentos.comprimento; ++i) {
            if (!momentos[i].isValid() || momentos[i][fn](res)) {
                res = momentos[i];
            }
        }
        retorno res;
    }

    // TODO: Use [].sort em vez disso?
    função min(){
        var argumentos = [].slice.call(argumentos, 0);

        return pickBy('isBefore', args);
    }

    função max() {
        var argumentos = [].slice.call(argumentos, 0);

        return pickBy('isAfter', args);
    }

    var agora = function() {
        retornar Data.agora? Date.now() : +new Date();
    };

    var ordenação = [
        'ano',
        'trimestre',
        'mês',
        'semana',
        'dia',
        'hora',
        'minuto',
        'segundo',
        'milissegundo',
    ];

    função éDuraçãoValid(m) {
        chave var,
            unitHasDecimal = false,
            eu,
            ordemLen = ordem.comprimento;
        for (digite m) {
            E se (
                hasOwnProp(m, chave) &&
                !(
                    indexOf.call(ordenação, chave) !== -1 &&
                    (m[chave] == null || !isNaN(m[chave])))
                )
            ) {
                retorna falso;
            }
        }

        for (i = 0; i < ordemLen; ++i) {
            if (m[pedido[i]]) {
                if (unidadeTemDecimal) {
                    retorna falso; // permite apenas números não inteiros para a menor unidade
                }
                if (parseFloat(m[ordenando[i]]) !== toInt(m[ordenando[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        retorne verdadeiro;
    }

    função éValida$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    função Duração(duração) {
        var normalizedInput = normalizeObjectUnits(duração),
            anos = entrada normalizada.ano || 0,
            trimestres = entrada normalizada.quarto || 0,
            meses = entrada normalizada.mês || 0,
            semanas = entrada normalizada.semana || normalizedInput.isoWeek || 0,
            dias = entrada normalizada.dia || 0,
            horas = entrada normalizada.hora || 0,
            minutos = entrada normalizada.minuto || 0,
            segundos = entrada normalizada.segundo || 0,
            milissegundos = entrada normalizada.milissegundos || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representação para dateAddRemove
        this._milliseconds =
            +milissegundos +
            segundos * 1e3 + // 1000
            minutos * 6e4 + // 1000 * 60
            horas * 1000 * 60 * 60; //usando 1000 * 60 * 60 em vez de 36e5 para evitar erros de arredondamento de ponto flutuante https://github.com/moment/moment/issues/2978
        // Por causa de dateAddRemove trata 24 horas como diferente de um
        // dia ao trabalhar em torno do horário de verão, precisamos armazená-los separadamente
        this._days = +dias + semanas * 7;
        // É impossível traduzir meses em dias sem saber
        // de quais meses você está falando, então temos que armazenar
        //-lo separadamente.
        this._months = +meses + trimestres * 3 + anos * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    função éDuração(obj) {
        return obj instanceof Duration;
    }

    função absRound(número) {
        if (número < 0) {
            return Math.round(-1 * número) * -1;
        } senão {
            return Math.round(número);
        }
    }

    // compara dois arrays, retorna o número de diferenças
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            comprimentoDiff = Math.abs(array1.length - array2.length),
            diferenças = 0,
            eu;
        for (i = 0; i < len; i++) {
            E se (
                (nãoConverter && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
            ) {
                diferenças++;
            }
        }
        retornar diferenças + comprimentoDif;
    }

    // FORMATAÇÃO

    function offset(token, separador) {
        addFormatToken(token, 0, 0, function() {
            var offset = this.utcOffset(),
                sinal = '+';
            if (deslocamento < 0) {
                deslocamento = -deslocamento;
                sinal = '-';
            }
            Retorna (
                sinal +
                zeroFill(~~(deslocamento / 60), 2) +
                separador +
                zeroFill(~~deslocamento % 60, 2)
            );
        });
    }

    offset('Z', ':');
    offset('ZZ','');

    // ANALISANDO

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], função (entrada, matriz, configuração) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, entrada);
    });

    // AJUDANTES

    // fragmentador de fuso horário
    // '+10:00' > ['10', '00']
    // '-1530' > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var corresponde = (string || '').match(matcher),
            pedaço,
            peças,
            minutos;

        if (corresponde === null) {
            retornar nulo;
        }

        pedaço = matchs[matches.length - 1] || [];
        partes = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        minutos = +(partes[1] * 60) + toInt(partes[2]);

        retornar minutos === 0 ? 0 : partes[0] === '+' ? minutos : -minutos;
    }

    // Retorna um momento da entrada, que é local/utc/zone equivalente a model.
    function cloneWithOffset(entrada, modelo) {
        var res, diff;
        if (model._isUTC) {
            res = modelo.clone();
            diferença =
                (isMoment(input) || isDate(input)
                    ? input.valueOf()
                    : createLocal(input).valueOf()) - res.valueOf();
            // Use api de baixo nível, porque este fn é api de baixo nível.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            retorno res;
        } senão {
            return createLocal(input).local();
        }
    }

    function getDateOffset(m) {
        // No Firefox.24 Date#getTimezoneOffset retorna um ponto flutuante.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset());
    }

    // GANCHOS

    // Esta função será chamada sempre que um momento for modificado.
    // Destina-se a manter o deslocamento em sincronia com o fuso horário.
    hooks.updateOffset = function () {};

    // MOMENTOS

    // keepLocalTime = true significa apenas alterar o fuso horário, sem
    // afetando a hora local. Então 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 É possível que 5:31:26 não exista com deslocamento
    // +0200, então ajustamos o tempo conforme necessário, para ser válido.
    //
    // Manter o tempo realmente adiciona/subtrai (uma hora)
    // do tempo real representado. É por isso que chamamos updateOffset
    // uma segunda vez. Caso queira que alteremos o deslocamento novamente
    // _changeInProgress == true case, então temos que ajustar, porque
    // não existe esse horário no fuso horário especificado.
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            ajuste local;
        if (!this.isValid()) {
            retorno de entrada!= null ? este: NaN;
        }
        if (input != null) {
            if (tipo de entrada === 'string') {
                entrada = offsetFromString(matchShortOffset, entrada);
                if (entrada === null) {
                    devolva isso;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                entrada = entrada * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (deslocamento !== entrada) {
                if (!keepLocalTime || this._changeInProgress) {
                    adicionarSubtrair(
                        isto,
                        createDuration(input - offset, 'm'),
                        1,
                        falso
                    );
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            devolva isso;
        } senão {
            retornar this._isUTC ? offset: getDateOffset(this);
        }
    }

    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                entrada = -entrada;
            }

            this.utcOffset(input, keepLocalTime);

            devolva isso;
        } senão {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (manterHoraLocal) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        devolva isso;
    }

    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZona != null) {
                this.utcOffset(tZone);
            } senão {
                this.utcOffset(0, verdadeiro);
            }
        }
        devolva isso;
    }

    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            retorna falso;
        }
        entrada = entrada? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - entrada) % 60 === 0;
    }

    function isDaylightSavingTime() {
        Retorna (
            this.utcOffset() > this.clone().mês(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {},
            outro;

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            outro = c._isUTC ? createUTC(c._a): createLocal(c._a);
            this._isDSTShifted =
                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } senão {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    função éLocal() {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }

    função éUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json formato de data regex
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)? )?$/,
        // de http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // um pouco mais de acordo com a especificação 4.4.3.2 2004, mas permite decimal em qualquer lugar
        // e modificado para permitir strings contendo semana e dia
        isoRegex =
            /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M )?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(? :([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[ 0-9,.]*)S)?)?$/;

    function createDuration(entrada, chave) {
        var duração = entrada,
            // combinar com regexp é caro, faça sob demanda
            corresponder = nulo,
            sinal,
            ret,
            difRes;

        if (éDuração(entrada)) {
            duração = {
                ms: entrada._milissegundos,
                d: input._days,
                M: entrada._meses,
            };
        } else if (isNumber(input) || !isNaN(+input)) {
            duração = {};
            if (chave) {
                duração[chave] = +entrada;
            } senão {
                duração.milissegundos = +entrada;
            }
        } else if ((correspondência = aspNetRegex.exec(entrada))) {
            sinal = partida[1] === '-'? -1: 1;
            duração = {
                y: 0,
                d: toInt(match[DATE]) * sinal,
                h: toInt(match[HOUR]) * sinal,
                m: toInt(match[MINUTE]) * sinal,
                s: toInt(match[SECOND]) * sinal,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // o ponto decimal do milissegundo é incluído na correspondência
            };
        } else if ((correspondência = isoRegex.exec(entrada))) {
            sinal = partida[1] === '-'? -1: 1;
            duração = {
                y: parseIso(match[2], sinal),
                M: parseIso(match[3], sinal),
                w: parseIso(match[4], sinal),
                d: parseIso(match[5], sinal),
                h: parseIso(match[6], sinal),
                m: parseIso(match[7], sinal),
                s: parseIso(match[8], sinal),
            };
        } else if (duração == null) {
            // verifica se é nulo ou indefinido
            duração = {};
        } senão se (
            typeof duração === 'objeto' &&
            ('de' em duração || 'para' em duração)
        ) {
            diferençaRes = momentosDiferença(
                createLocal(duração.de),
                createLocal(duração.para)
            );

            duração = {};
            duração.ms = diffRes.milissegundos;
            duração.M = diferençaRes.meses;
        }

        ret = new Duração(duração);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
        }

        retorno ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sinal) {
        // Normalmente usaríamos ~~inp para isso, mas infelizmente também
        // converte floats em inteiros.
        // inp pode ser indefinido, então chame o replace com cuidado.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // aplica o sinal enquanto estamos nisso
        return (isNaN(res) ? 0 : res) * sinal;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.meses =
            outro.mês() - base.mês() + (outro.ano() - base.ano()) * 12;
        if (base.clone().add(res.meses, 'M').isAfter(other)) {
            --res.meses;
        }

        res.milissegundos = +outro - +base.clone().add(res.meses, 'M');

        retorno res;
    }

    function momentosDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return { milissegundos: 0, meses: 0 };
        }

        outro = cloneWithOffset(outro, base);
        if (base.isBefore(other)) {
            res = positivoMomentosDifference(base, outro);
        } senão {
            res = positivoMomentosDifference(other, base);
            res.milissegundos = -res.milissegundos;
            res.meses = -res.meses;
        }

        retorno res;
    }

    // TODO: remove o argumento 'name' após a remoção da depreciação
    function createAdder(direção, nome) {
        função de retorno (val, período) {
            var dur, tmp;
            //inverte os argumentos, mas reclama
            if (ponto !== null && !isNaN(+ponto)) {
                deprecateSimple(
                    nome,
                    'momento().' +
                        nome +
                        '(ponto, número) está obsoleto. Por favor, use moment().' +
                        nome +
                        '(número, período). ' +
                        'Veja http://momentjs.com/guides/#/warnings/add-inverted-param/ para mais informações.'
                );
                tmp = val;
                val = período;
                período = tmp;
            }

            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            devolva isso;
        };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milissegundos = duração._milissegundos,
            dias = absRound(duração._dias),
            meses = absRound(duração._meses);

        if (!mãe.isValid()) {
            // Sem operação
            Retorna;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        se (meses) {
            setMonth(mãe, get(mãe, 'Mês') + meses * isAdding);
        }
        se (dias) {
            set$1(mãe, 'Data', get(mãe, 'Data') + dias * isAdding);
        }
        if (milissegundos) {
            mom._d.setTime(mom._d.valueOf() + milissegundos * isAdding);
        }
        if (atualizarDeslocamento) {
            hooks.updateOffset(mãe, dias || meses);
        }
    }

    var adicionar = criarAdicionador(1, 'adicionar'),
        subtrair = createAdder(-1, 'subtrair');

    função isString(entrada) {
        return typeof input === 'string' || input instanceof String;
    }

    // digite MomentInput = Momento | Data | seqüência | número | (número | string)[] | MomentInputObject | vazio; // nulo | Indefinido
    function isMomentInput(input) {
        Retorna (
            isMoment(entrada) ||
            isDate(entrada) ||
            isString(entrada) ||
            isNumero(entrada) ||
            isNumberOrStringArray(entrada) ||
            isMomentInputObject(input) ||
            entrada === null ||
            entrada === indefinido
        );
    }

    function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propriedadeTeste = false,
            propriedades = [
                'anos',
                'ano',
                's',
                'meses',
                'mês',
                'M',
                'dias',
                'dia',
                'd',
                'datas',
                'encontro',
                'D',
                'horas',
                'hora',
                'h',
                'minutos',
                'minuto',
                'm',
                'segundos',
                'segundo',
                's',
                'milissegundos',
                'milissegundo',
                'EM',
            ],
            eu,
            propriedade,
            propriedadeLen = propriedades.comprimento;

        for (i = 0; i < propertyLen; i += 1) {
            propriedade = propriedades[i];
            propriedadeTeste = propriedadeTeste || hasOwnProp(entrada, propriedade);
        }

        return objectTest && propertyTest;
    }

    function isNumberOrStringArray(entrada) {
        var arrayTeste = isArray(entrada),
            dataTypeTest = false;
        if (arrayTeste) {
            dataTypeTest =
                input.filter(função (item) {
                    return !isNumber(item) && isString(input);
                }).comprimento === 0;
        }
        return arrayTest && dataTypeTest;
    }

    function isCalendarSpec(entrada) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propriedadeTeste = false,
            propriedades = [
                'mesmo dia',
                'próximo dia',
                'último dia',
                'semana que vem',
                'Semana Anterior',
                'mesmoSenão',
            ],
            eu,
            propriedade;

        for (i = 0; i < propriedades.comprimento; i += 1) {
            propriedade = propriedades[i];
            propriedadeTeste = propriedadeTeste || hasOwnProp(entrada, propriedade);
        }

        return objectTest && propertyTest;
    }

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(agora, 'dias', true);
        retorno diferencial < -6
            ? 'mesmoSenão'
            : diferença < -1
            ? 'Semana Anterior'
            : diferença < 0
            ? 'último dia'
            : diferença < 1
            ? 'mesmo dia'
            : diferença < 2
            ? 'próximo dia'
            : diferença < 7
            ? 'semana que vem'
            : 'mesmoSenão';
    }

    função calendar$1(hora, formatos) {
        // Suporte para parâmetro único, formatos apenas sobrecarregam a função de calendário
        if (argumentos.comprimento === 1) {
            if (!argumentos[0]) {
                tempo = indefinido;
                formatos = indefinido;
            } else if (isMomentInput(arguments[0])) {
                tempo = argumentos[0];
                formatos = indefinido;
            } else if (isCalendarSpec(arguments[0])) {
                formatos = argumentos[0];
                tempo = indefinido;
            }
        }
        // Queremos comparar o início de hoje com este.
        // Começar hoje depende se somos locais/utc/offset ou não.
        var agora = tempo || criarLocal(),
            sod = cloneWithOffset(agora, isso).startOf('dia'),
            format = hooks.calendarFormat(this, sod) || 'mesmoSenão',
            saída =
                formatos &&
                (isFunction(formatos[formato])
                    ? format[format].call(this, now)
                    : formatos[formato]);

        return this.format(
            saída || this.localeData().calendar(format, this, createLocal(now))
        );
    }

    função clone() {
        return novo Momento(this);
    }

    function isAfter(entrada, unidades) {
        var localInput = isMoment(input) ? entrada: criarLocal(entrada);
        if (!(this.isValid() && localInput.isValid())) {
            retorna falso;
        }
        unidades = normalizeUnidades(unidades) || 'milissegundo';
        if (unidades === 'milissegundo') {
            return this.valueOf() > localInput.valueOf();
        } senão {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore(entrada, unidades) {
        var localInput = isMoment(input) ? entrada: criarLocal(entrada);
        if (!(this.isValid() && localInput.isValid())) {
            retorna falso;
        }
        unidades = normalizeUnidades(unidades) || 'milissegundo';
        if (unidades === 'milissegundo') {
            return this.valueOf() < localInput.valueOf();
        } senão {
            return this.clone().endOf(unidades).valueOf() < localInput.valueOf();
        }
    }

    function isBetween(de, para, unidades, inclusão) {
        var localFrom = isMoment(from) ? de : createLocal(de),
            localTo = isMoment(to) ? para: criarLocal(para);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            retorna falso;
        }
        inclusão = inclusão || '()';
        Retorna (
            (inclusividade[0] === '('
                ? this.isAfter(localFrom, unidades)
                : !this.isBefore(localFrom, units)) &&
            (inclusividade[1] === ')'
                ? this.isBefore(localTo, unidades)
                : !this.isAfter(localTo, unidades))
        );
    }

    function isSame(entrada, unidades) {
        var localInput = isMoment(input) ? entrada: criarLocal(entrada),
            entradaMs;
        if (!(this.isValid() && localInput.isValid())) {
            retorna falso;
        }
        unidades = normalizeUnidades(unidades) || 'milissegundo';
        if (unidades === 'milissegundo') {
            return this.valueOf() === localInput.valueOf();
        } senão {
            inputMs = localInput.valueOf();
            Retorna (
                this.clone().startOf(unidades).valueOf() <= inputMs &&
                inputMs <= this.clone().endOf(units).valueOf()
            );
        }
    }

    function isSameOrAfter(entrada, unidades) {
        return this.isSame(entrada, unidades) || this.isAfter(entrada, unidades);
    }

    function isSameOrBefore(entrada, unidades) {
        return this.isSame(entrada, unidades) || this.isBefore(entrada, unidades);
    }

    function diff(entrada, unidades, asFloat) {
        var that, zoneDelta, output;

        if (!this.isValid()) {
            retornar NaN;
        }

        that = cloneWithOffset(input, this);

        if (!isso.éválido()) {
            retornar NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        unidades = normalizeUnidades(unidades);

        interruptor (unidades) {
            caso 'ano':
                saída = mêsDiff(isso, aquilo) / 12;
                parar;
            caso 'mês':
                saída = mêsDiff(isso, aquilo);
                parar;
            caso 'trimestre':
                saída = mêsDiff(isso, aquilo) / 3;
                parar;
            caso 'segundo':
                saída = (isto - aquilo) / 1e3;
                parar; // 1000
            caso 'minuto':
                saída = (isto - aquilo) / 6e4;
                parar; // 1000 * 60
            caso 'hora':
                saída = (isto - aquilo) / 36e5;
                parar; // 1000 * 60 * 60
            caso 'dia':
                output = (this - that - zoneDelta) / 864e5;
                parar; // 1000 * 60 * 60 * 24, nega dst
            caso 'semana':
                output = (este - aquele - zoneDelta) / 6048e5;
                parar; // 1000 * 60 * 60 * 24 * 7, nega dst
            predefinição:
                saída = isso - aquilo;
        }

        return asFloat ? saída: absFloor(saída);
    }

    função mêsDif(a, b) {
        if (a.data() < b.data()) {
            // os cálculos de fim de mês funcionam corretamente quando o mês inicial tem mais
            // dias que o mês final.
            return -mêsDif(b, a);
        }
        //diferença em meses
        var wholeMonthDiff = (b.ano() - a.ano()) * 12 + (b.mês() - a.mês()),
            // b está em (âncora - 1 mês, âncora + 1 mês)
            âncora = a.clone().add(wholeMonthDiff, 'meses'),
            âncora2,
            ajustar;

        if (b - âncora < 0) {
            âncora2 = a.clone().add(wholeMonthDiff - 1, 'meses');
            // linear ao longo do mês
            ajuste = (b - âncora) / (âncora - âncora2);
        } senão {
            âncora2 = a.clone().add(wholeMonthDiff + 1, 'meses');
            // linear ao longo do mês
            ajuste = (b - âncora) / (âncora2 - âncora);
        }

        //verifica se há zero negativo, retorna zero se zero negativo
        return -(wholeMonthDiff + ajuste) || 0;
    }

    hooks.defaultFormat = 'AAAA-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'AAAA-MM-DDTHH:mm:ss[Z]';

    function toString() {
        return this.clone().locale('pt').format('ddd MMM DD AAAA HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            retornar nulo;
        }
        var utc = keepOffset !== true,
            m = ut? this.clone().utc() : this;
        if (m.ano() < 0 || m.ano() > 9999) {
            return formatoMomento(
                m,
                utc
                    ? 'AAAA-MM-DD[T]HH:mm:ss.SSS[Z]'
                    : 'AAAA-MM-DD[T]HH:mm:ss.SSSZ'
            );
        }
        if (isFunction(Date.prototype.toISOString)) {
            // implementação nativa é ~50x mais rápida, use-a quando puder
            se (utc) {
                return this.toDate().toISOString();
            } senão {
                retornar nova Data(this.valueOf() + this.utcOffset() * 60 * 1000)
                    .toISOString()
                    .replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatoMomento(
            m,
            ut? 'AAAA-MM-DD[T]HH:mm:ss.SSS[Z]': 'AAAA-MM-DD[T]HH:mm:ss.SSSZ'
        );
    }

    /**
     * Retorna uma representação legível por humanos de um momento que pode
     * também ser avaliado para obter um novo momento que é o mesmo
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    função inspecionar() {
        if (!this.isValid()) {
            return 'momento.inválido(/* ' + this._i + ' */)';
        }
        var func = 'momento',
            zona = '',
            prefixo,
            ano,
            data hora,
            sufixo;
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'momento.utc' : 'momento.parseZone';
            zona = 'Z';
        }
        prefixo = '[' + func + '("]';
        ano = 0 <= este.ano() && este.ano() <= 9999 ? 'AAAA': 'AAAAAA';
        datetime = '-MM-DD[T]HH:mm:ss.SSS';
        sufixo = zona + '[")]';

        return this.format(prefixo + ano + data e hora + sufixo);
    }

    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc()
                ? hooks.defaultFormatUtc
                : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
        E se (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ to: this, from: time })
                .locale(this.locale())
                .humanize(!semSufixo);
        } senão {
            return this.localeData().invalidDate();
        }
    }

    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
        E se (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ from: this, to: time })
                .locale(this.locale())
                .humanize(!semSufixo);
        } senão {
            return this.localeData().invalidDate();
        }
    }

    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // Se passar uma chave de localidade, ela definirá a localidade para isso
    // instância. Caso contrário, ele retornará a configuração de localidade
    // variáveis ​​para esta instância.
    função locale(chave) {
        var newLocaleData;

        if (chave === indefinido) {
            return this._locale._abbr;
        } senão {
            newLocaleData = getLocale(chave);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            devolva isso;
        }
    }

    var lang = obsoleto(
        'moment().lang() está obsoleto. Em vez disso, use moment().localeData() para obter a configuração do idioma. Use moment().locale() para alterar os idiomas.',
        tecla de função) {
            if (chave === indefinido) {
                return this.localeData();
            } senão {
                return this.locale(chave);
            }
        }
    );

    function localeData() {
        retorne this._locale;
    }

    var MS_PER_SECOND = 1000,
        MS_PER_MINUTE = 60 * MS_PER_SECOND,
        MS_PER_HOUR = 60 * MS_PER_MINUTE,
        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // módulo real - lida com números negativos (para datas anteriores a 1970):
    função mod$1(dividendo, divisor) {
        return ((dividendo % divisor) + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // o construtor de data remapeia os anos 0-99 para 1900-1999
        if (y < 100 && y >= 0) {
            // preserva os anos bissextos usando um ciclo completo de 400 anos, depois reinicia
            retornar nova Data(y + 400, m, d) - MS_PER_400_YEARS;
        } senão {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remapeia os anos 0-99 para 1900-1999
        if (y < 100 && y >= 0) {
            // preserva os anos bissextos usando um ciclo completo de 400 anos, depois reinicia
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } senão {
            return Date.UTC(y, m, d);
        }
    }

    function startOf(unidades) {
        var hora, startOfDate;
        unidades = normalizeUnidades(unidades);
        if (unidades === indefinido || unidades === 'milissegundo' || !this.isValid()) {
            devolva isso;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        interruptor (unidades) {
            caso 'ano':
                hora = startOfDate(this.year(), 0, 1);
                parar;
            caso 'trimestre':
                hora = datainicial(
                    este ano(),
                    este.mês() - (este.mês() % 3),
                    1
                );
                parar;
            caso 'mês':
                hora = startOfDate(este.ano(), este.mês(), 1);
                parar;
            caso 'semana':
                hora = datainicial(
                    este ano(),
                    este mês(),
                    this.date() - this.weekday()
                );
                parar;
            case 'isoWeek':
                hora = datainicial(
                    este ano(),
                    este mês(),
                    this.date() - (this.isoWeekday() - 1)
                );
                parar;
            caso 'dia':
            caso 'data':
                tempo = startOfDate(this.year(), this.month(), this.date());
                parar;
            caso 'hora':
                tempo = this._d.valueOf();
                tempo -= mod$1(
                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                    MS_PER_HOUR
                );
                parar;
            caso 'minuto':
                tempo = this._d.valueOf();
                hora -= mod$1(hora, MS_PER_MINUTE);
                parar;
            caso 'segundo':
                tempo = this._d.valueOf();
                hora -= mod$1(hora, MS_PER_SECOND);
                parar;
        }

        this._d.setTime(tempo);
        hooks.updateOffset(this, true);
        devolva isso;
    }

    function endOf(unidades) {
        var hora, startOfDate;
        unidades = normalizeUnidades(unidades);
        if (unidades === indefinido || unidades === 'milissegundo' || !this.isValid()) {
            devolva isso;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        interruptor (unidades) {
            caso 'ano':
                hora = startOfDate(este.ano() + 1, 0, 1) - 1;
                parar;
            caso 'trimestre':
                tempo =
                    data de início(
                        este ano(),
                        este.mês() - (este.mês() % 3) + 3,
                        1
                    ) - 1;
                parar;
            caso 'mês':
                tempo = startOfDate(este.ano(), este.mês() + 1, 1) - 1;
                parar;
            caso 'semana':
                tempo =
                    data de início(
                        este ano(),
                        este mês(),
                        this.date() - this.weekday() + 7
                    ) - 1;
                parar;
            case 'isoWeek':
                tempo =
                    data de início(
                        este ano(),
                        este mês(),
                        this.date() - (this.isoWeekday() - 1) + 7
                    ) - 1;
                parar;
            caso 'dia':
            caso 'data':
                tempo = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                parar;
            caso 'hora':
                tempo = this._d.valueOf();
                tempo +=
                    MS_PER_HOUR -
                    mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    ) -
                    1;
                parar;
            caso 'minuto':
                tempo = this._d.valueOf();
                hora += MS_PER_MINUTE - mod$1(hora, MS_PER_MINUTE) - 1;
                parar;
            caso 'segundo':
                tempo = this._d.valueOf();
                hora += MS_PER_SECOND - mod$1(hora, MS_PER_SECOND) - 1;
                parar;
        }

        this._d.setTime(tempo);
        hooks.updateOffset(this, true);
        devolva isso;
    }

    função valorOf() {
        return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    função unix() {
        return Math.floor(this.valueOf() / 1000);
    }

    função paraData() {
        return new Date(this.valueOf());
    }

    function paraArray() {
        var m = isso;
        Retorna [
            minha orelha(),
            m.mês(),
            m.data(),
            m.hora(),
            m.minuto(),
            m.segundo(),
            m.milissegundo(),
        ];
    }

    função paraObjeto() {
        var m = isso;
        Retorna {
            anos: m.ano(),
            meses: m.mês(),
            data: m.data(),
            horas: m.horas(),
            minutos: m.minutos(),
            segundos: m.segundos(),
            milissegundos: m.milissegundos(),
        };
    }

    função paraJSON() {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    função éValida$2() {
        return isValid(this);
    }

    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
        return getParsingFlags(this).overflow;
    }

    função criaçãoDados() {
        Retorna {
            entrada: this._i,
            formato: this._f,
            localidade: this._locale,
            isUTC: this._isUTC,
            estrito: this._strict,
        };
    }

    addFormatToken('N', 0, 0, 'eraAbbr');
    addFormatToken('NN', 0, 0, 'eraAbbr');
    addFormatToken('NNN', 0, 0, 'eraAbbr');
    addFormatToken('NNNN', 0, 0, 'eraName');
    addFormatToken('NNNNN', 0, 0, 'eraNarrow');

    addFormatToken('y', ['y', 1], 'yo', 'eraYear');
    addFormatToken('y', ['yy', 2], 0, 'eraYear');
    addFormatToken('y', ['yyy', 3], 0, 'eraYear');
    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

    addRegexToken('N', matchEraAbbr);
    addRegexToken('NN', matchEraAbbr);
    addRegexToken('NNN', matchEraAbbr);
    addRegexToken('NNNN', matchEraName);
    addRegexToken('NNNNN', matchEraNarrow);

    addParseToken(
        ['N', 'NN', 'NNN', 'NNNN', 'NNNNN'],
        function (entrada, array, configuração, token) {
            var era = config._locale.erasParse(entrada, token, config._strict);
            se (era) {
                getParsingFlags(config).era = era;
            } senão {
                getParsingFlags(config).invalidEra = input;
            }
        }
    );

    addRegexToken('y', matchUnsigned);
    addRegexToken('yy', matchUnsigned);
    addRegexToken('yyy', matchUnsigned);
    addRegexToken('yyyy', matchUnsigned);
    addRegexToken('yo', matchEraYearOrdinal);

    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
    addParseToken(['yo'], function (entrada, array, config, token) {
        var partida;
        if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
        }

        if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } senão {
            array[ANO] = parseInt(entrada, 10);
        }
    });

    function localeEras(m, formato) {
        var eu,
            eu,
            encontro,
            eras = this._eras || getLocale('pt')._eras;
        for (i = 0, l = eras.comprimento; i < l; ++i) {
            switch (tipo de eras[i].desde) {
                caso 'string':
                    //truncar o tempo
                    data = hooks(eras[i].since).startOf('dia');
                    eras[i].since = date.valueOf();
                    parar;
            }

            switch (typeof eras[i].until) {
                caso 'indefinido':
                    eras[i].até = +Infinito;
                    parar;
                caso 'string':
                    //truncar o tempo
                    data = hooks(eras[i].until).startOf('dia').valueOf();
                    eras[i].until = date.valueOf();
                    parar;
            }
        }
        eras de retorno;
    }

    function localeErasParse(eraName, format, strict) {
        var eu,
            eu,
            eras = this.eras(),
            nome,
            abre,
            estreito;
        eraName = eraName.toUpperCase();

        for (i = 0, l = eras.comprimento; i < l; ++i) {
            nome = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            estreito = eras[i].narrow.toUpperCase();

            se (estrito) {
                mudar (formato) {
                    caso 'N':
                    caso 'NN':
                    caso 'NNN':
                        if (abbr === eraName) {
                            retornar eras[i];
                        }
                        parar;

                    caso 'NNNN':
                        if (nome === eraName) {
                            retornar eras[i];
                        }
                        parar;

                    caso 'NNNNN':
                        if (restringir === eraName) {
                            retornar eras[i];
                        }
                        parar;
                }
            } else if ([nome, abbr, estreito].indexOf(eraName) >= 0) {
                retornar eras[i];
            }
        }
    }

    function localeErasConvertYear(era, ano) {
        var dir = era.since <= era.until ? +1: -1;
        if (ano === indefinido) {
            return ganchos(era.desde).ano();
        } senão {
            return hooks(era.since).year() + (year - era.offset) * dir;
        }
    }

    function getEraName() {
        var eu,
            eu,
            vale,
            eras = this.localeData().eras();
        for (i = 0, l = eras.comprimento; i < l; ++i) {
            //truncar o tempo
            val = this.clone().startOf('dia').valueOf();

            if (eras[i].desde <= val && val <= eras[i].until) {
                return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].desde) {
                return eras[i].name;
            }
        }

        Retorna '';
    }

    function getEraNarrow() {
        var eu,
            eu,
            vale,
            eras = this.localeData().eras();
        for (i = 0, l = eras.comprimento; i < l; ++i) {
            //truncar o tempo
            val = this.clone().startOf('dia').valueOf();

            if (eras[i].desde <= val && val <= eras[i].until) {
                retornar eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].desde) {
                retornar eras[i].narrow;
            }
        }

        Retorna '';
    }

    function getEraAbbr() {
        var eu,
            eu,
            vale,
            eras = this.localeData().eras();
        for (i = 0, l = eras.comprimento; i < l; ++i) {
            //truncar o tempo
            val = this.clone().startOf('dia').valueOf();

            if (eras[i].desde <= val && val <= eras[i].until) {
                return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].desde) {
                return eras[i].abbr;
            }
        }

        Retorna '';
    }

    function getEraAno() {
        var eu,
            eu,
            dir,
            vale,
            eras = this.localeData().eras();
        for (i = 0, l = eras.comprimento; i < l; ++i) {
            dir = eras[i].desde <= eras[i].até ? +1: -1;

            //truncar o tempo
            val = this.clone().startOf('dia').valueOf();

            E se (
                (eras[i].desde <= val && val <= eras[i].until) ||
                (eras[i].até <= val && val <= eras[i].desde)
            ) {
                Retorna (
                    (this.year() - hooks(eras[i].since).year()) * dir +
                    eras[i].offset
                );
            }
        }

        return este.ano();
    }

    function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNameRegex')) {
            computaErasParse.call(this);
        }
        retornar isStrict ? this._erasNameRegex : this._erasRegex;
    }

    function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computaErasParse.call(this);
        }
        retornar isStrict ? this._erasAbbrRegex : this._erasRegex;
    }

    function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computaErasParse.call(this);
        }
        retornar isStrict ? this._erasNarrowRegex : this._erasRegex;
    }

    function matchEraAbbr(isStrict, locale) {
        return locale.erasAbbrRegex(isStrict);
    }

    function matchEraName(isStrict, locale) {
        return locale.erasNameRegex(isStrict);
    }

    function matchEraNarrow(isStrict, locale) {
        return locale.erasNarrowRegex(isStrict);
    }

    function matchEraYearOrdinal(isStrict, locale) {
        return locale._eraYearOrdinalRegex || matchNão assinado;
    }

    function computaErasParse() {
        var abbrPeças = [],
            nomePeças = [],
            estreitaPeças = [],
            peças mistas = [],
            eu,
            eu,
            eras = this.eras();

        for (i = 0, l = eras.comprimento; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));

            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
        }

        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
        this._erasNarrowRegex = new RegExp(
            '^(' + narrowPieces.join('|') + ')',
            'eu'
        );
    }

    // FORMATAÇÃO

    addFormatToken(0, ['gg', 2], 0, function() {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, função () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // APELIDO

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORIDADE

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);

    // ANALISANDO

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);

    addWeekParseToken(
        ['gggg', 'gggggg', 'GGGG', 'GGGGG'],
        function (entrada, semana, configuração, token) {
            semana[token.substr(0, 2)] = toInt(entrada);
        }
    );

    addWeekParseToken(['gg', 'GG'], função (entrada, semana, configuração, token) {
        semana[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTOS

    function getSetWeekYear(entrada) {
        return getSetWeekYearHelper.call(
            isto,
            entrada,
            essa semana(),
            este.dia da semana(),
            this.localeData()._week.dow,
            this.localeData()._week.doy
        );
    }

    function getSetISOWeekYear(entrada) {
        return getSetWeekYearHelper.call(
            isto,
            entrada,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
        );
    }

    function getISOWeeksInYear() {
        return semanasEmAno(este.ano(), 1, 4);
    }

    function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
    }

    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var semanasDestino;
        if (entrada == null) {
            return semanaDoAno(este, dow, doy).ano;
        } senão {
            semanasDestino = semanasEmAno(entrada, dow, doy);
            if (semana > semanasTarget) {
                semana = semanasAlvo;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            data = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        devolva isso;
    }

    // FORMATAÇÃO

    addFormatToken('Q', 0, 'Qo', 'trimestre');

    // APELIDO

    addUnitAlias('trimestre', 'Q');

    // PRIORIDADE

    addUnitPriority('trimestre', 7);

    // ANALISANDO

    addRegexToken('Q', match1);
    addParseToken('Q', function (entrada, array) {
        array[MÊS] = (toInt(entrada) - 1) * 3;
    });

    // MOMENTOS

    function getSetQuarter(entrada) {
        entrada de retorno == null
            ? Math.ceil((este.mês() + 1) / 3)
            : este.mês((entrada - 1) * 3 + (este.mês() % 3));
    }

    // FORMATAÇÃO

    addFormatToken('D', ['DD', 2], 'Do', 'data');

    // APELIDO

    addUnitAlias('data', 'D');

    // PRIORIDADE
    addUnitPriority('data', 9);

    // ANALISANDO

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remova o fallback "ordinalParse" na próxima versão principal.
        return isStrict
            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
            : locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATA);
    addParseToken('Do', function (entrada, array) {
        array[DATA] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTOS

    var getSetDayOfMonth = makeGetSet('Data', true);

    // FORMATAÇÃO

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // APELIDO

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORIDADE
    addUnitPriority('diaDoAno', 4);

    // ANALISANDO

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (entrada, array, config) {
        config._dayOfYear = toInt(input);
    });

    // AJUDANTES

    // MOMENTOS

    function getSetDayOfYear(entrada) {
        var diaDoAno =
            Math.round(
                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
            ) + 1;
        entrada de retorno == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    }

    // FORMATAÇÃO

    addFormatToken('m', ['mm', 2], 0, 'minuto');

    // APELIDO

    addUnitAlias('minuto', 'm');

    // PRIORIDADE

    addUnitPriority('minuto', 14);

    // ANALISANDO

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTO);

    // MOMENTOS

    var getSetMinute = makeGetSet('Minutos', false);

    // FORMATAÇÃO

    addFormatToken('s', ['ss', 2], 0, 'segundo');

    // APELIDO

    addUnitAlias('segundo', 's');

    // PRIORIDADE

    addUnitPriority('segundo', 15);

    // ANALISANDO

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTOS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATAÇÃO

    addFormatToken('S', 0, 0, function() {
        return ~~(this.milissegundo() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, função () {
        return ~~(this.milissegundo() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'milissegundo');
    addFormatToken(0, ['SSSS', 4], 0, função () {
        return this.milissegundo() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, função () {
        return this.milissegundo() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, função () {
        return this.milissegundo() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, função () {
        return this.milissegundo() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, função () {
        return this.milissegundo() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, função () {
        return this.milissegundo() * 1000000;
    });

    // APELIDO

    addUnitAlias('milissegundo', 'ms');

    // PRIORIDADE

    addUnitPriority('milissegundo', 16);

    // ANALISANDO

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);

    var token, getSetMillisecond;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(entrada, array) {
        array[MILISECOND] = toInt(('0.' + entrada) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }

    getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATAÇÃO

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTOS

    function getZoneAbbr() {
        retornar this._isUTC ? 'UTC':';
    }

    function getZoneName() {
        retornar this._isUTC ? 'Tempo Universal Coordenado' :'';
    }

    var proto = Moment.prototype;

    proto.adicionar = adicionar;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.formato = formato;
    proto.de = de;
    proto.fromNow = fromNow;
    proto.to = para;
    proto.toAgora = toAgora;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isDepois = éDepois;
    proto.isAntes = isAntes;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = protótipoMax;
    proto.min = protótipoMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtrair = subtrair;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspecionar = inspecionar;
    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Momento<' + this.format() + '>';
        };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valorOf = valorOf;
    proto.criaçãoDados =criaçãoDados;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.ano = getSetAno;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarto = proto.quartos = getSetQuarter;
    proto.mês = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.semana = proto.semanas = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hora = proto.horas = getSetHour;
    proto.minuto = proto.minutos = getSetMinute;
    proto.segundo = proto.segundos = getSetSecond;
    proto.milissegundos = proto.milissegundos = getSetMilisegundos;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = obsoleto(
        'dates está obsoleto. Use data em vez disso.',
        getSetDayOfMonth
    );
    proto.meses = obsoleto(
        'months acessador está obsoleto. Use mês em vez disso',
        getSetMonth
    );
    proto.anos = obsoleto(
        'years acessador está obsoleto. Em vez disso, use o ano',
        getSetYear
    );
    proto.zone = obsoleto(
        'moment().zone está obsoleto, use moment().utcOffset em vez disso. http://momentjs.com/guides/#/warnings/zone/',
        getSetZone
    );
    proto.isDSTShifted = obsoleto(
        'isDSTShifted está obsoleto. Consulte http://momentjs.com/guides/#/warnings/dst-shifted/ para obter mais informações',
        isDaylightSavingTimeShifted
    );

    função criarUnix(entrada) {
        return createLocal(entrada * 1000);
    }

    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
        seqüência de retorno;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendário = calendário;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;

    proto$1.meses = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthRegex;
    proto$1.monthsShortRegex = mesesShortRegex;
    proto$1.semana = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;

    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = dias da semanaMinRegex;

    proto$1.isPM = localIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(formato, índice, campo, setter) {
        var local = getLocal(),
            utc = createUTC().set(setter, index);
        return locale[campo](utc, formato);
    }

    function listMonthsImpl(formato, índice, campo) {
        if (éNúmero(formato)) {
            índice = formato;
            formato = indefinido;
        }

        formato = formato || '';

        if (índice != null) {
            return get$1(formato, índice, campo, 'mês');
        }

        var eu,
            fora = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(formato, i, campo, 'mês');
        }
        retornar;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fm)
    // (verdadeiro)
    // (verdadeiro, 5)
    // (verdadeiro, fmt, 5)
    // (verdadeiro, fmt)
    function listWeekdaysImpl(localeSorted, formato, índice, campo) {
        if (typeof localeSorted === 'boolean') {
            if (éNúmero(formato)) {
                índice = formato;
                formato = indefinido;
            }

            formato = formato || '';
        } senão {
            formato = localeSorted;
            índice = formato;
            localeOrdenado = false;

            if (éNúmero(formato)) {
                índice = formato;
                formato = indefinido;
            }

            formato = formato || '';
        }

        var local = getLocal(),
            shift = localeSorted ? locale._week.dow : 0,
            eu,
            fora = [];

        if (índice != null) {
            return get$1(formato, (índice + turno) % 7, campo, 'dia');
        }

        for (i = 0; i < 7; i++) {
            out[i] = get$1(formato, (i + turno) % 7, campo, 'dia');
        }
        retornar;
    }

    function listMonths(formato, índice) {
        return listMonthsImpl(formato, índice, 'meses');
    }

    function listMonthsShort(formato, índice) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, formato, índice) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('pt', {
        época: [
            {
                desde: '0001-01-01',
                até: +Infinito,
                deslocamento: 1,
                nome: 'Anno Domini',
                estreito: 'AD',
                abr: 'AD',
            },
            {
                desde: '0000-12-31',
                até: -Infinito,
                deslocamento: 1,
                nome: 'Antes de Cristo',
                estreito: 'BC',
                abr: 'BC',
            },
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: função (número) {
            var b = número % 10,
                saída =
                    toInt((número % 100) / 10) === 1
                        ? 'º'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'º';
            número de retorno + saída;
        },
    });

    // Importações de efeitos colaterais

    hooks.lang = obsoleto(
        'moment.lang está obsoleto. Use moment.locale em vez disso.',
        getSetGlobalLocale
    );
    hooks.langData = obsoleto(
        'moment.langData está obsoleto. Use moment.localeData em vez disso.',
        getLocale
    );

    var mathAbs = Math.abs;

    função abs() {
        var dados = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);

        dados.milissegundos = mathAbs(dados.milissegundos);
        dados.segundos = mathAbs(dados.segundos);
        dados.minutos = mathAbs(dados.minutos);
        data.horas = mathAbs(data.horas);
        data.meses = mathAbs(dados.meses);
        dados.anos = mathAbs(dados.anos);

        devolva isso;
    }

    function addSubtract$1(duração, entrada, valor, direção) {
        var outro = createDuration(entrada, valor);

        duração._milissegundos += direção * other._milissegundos;
        duration._days += direção * other._days;
        duração._meses += direção * outros._meses;

        return duração._bubble();
    }

    // suporta apenas add(1, 's') ou add(duration) estilo 2.0
    função soma $ 1(entrada, valor) {
        return addSubtract$1(this, input, value, 1);
    }

    // suporta apenas subtrair(1, 's') ou subtrair(duração) estilo 2.0
    function subtrair$1(entrada, valor) {
        return addSubtract$1(this, input, value, -1);
    }

    função absCeil(número) {
        if (número < 0) {
            return Math.floor(número);
        } senão {
            return Math.ceil(número);
        }
    }

    função bolha() {
        var milissegundos = this._milliseconds,
            dias = this._days,
            meses = this._months,
            dados = this._data,
            segundos,
            minutos,
            horas,
            anos,
            mesesDeDias;

        // se tivermos uma mistura de valores positivos e negativos, desça primeiro
        // verifique: https://github.com/moment/moment/issues/2166
        E se (
            !(
                (milissegundos >= 0 && dias >= 0 && meses >= 0) ||
                (milissegundos <= 0 && dias <= 0 && meses <= 0)
            )
        ) {
            milissegundos += absCeil(mesesToDays(meses) + dias) * 864e5;
            dias = 0;
            meses = 0;
        }

        // O código a seguir borbulha valores, veja os testes para
        // exemplos do que isso significa.
        data.milissegundos = milissegundos % 1000;

        segundos = absFloor(milissegundos / 1000);
        data.seconds = segundos % 60;

        minutos = absFloor(segundos / 60);
        dados.minutos = minutos % 60;

        horas = absFloor(minutos / 60);
        data.horas = horas % 24;

        dias += absFloor(horas / 24);

        // converte dias para meses
        monthFromDays = absFloor(daysToMonths(days));
        meses += mesesDeDias;
        dias -= absCeil(monthsToDays(monthsFromDays));

        // 12 meses -> 1 ano
        anos = absFloor(meses / 12);
        meses %= 12;

        data.dias = dias;
        data.meses = meses;
        data.anos = anos;

        devolva isso;
    }

    função diasParaMês(dias) {
        // 400 anos tem 146097 dias (levando em conta as regras dos anos bissextos)
        // 400 anos tem 12 meses === 4800
        retorno (dias * 4800) / 146097;
    }

    função mesesParaDias(meses) {
        // o inverso de daysToMonths
        retorno (meses * 146097) / 4800;
    }

    função como(unidades) {
        if (!this.isValid()) {
            retornar NaN;
        }
        var dias,
            meses,
            milissegundos = this._milliseconds;

        unidades = normalizeUnidades(unidades);

        if (unidades === 'mês' || unidades === 'trimestre' || unidades === 'ano') {
            dias = this._days + milissegundos / 864e5;
            meses = this._months + daysToMonths(days);
            interruptor (unidades) {
                caso 'mês':
                    meses de retorno;
                caso 'trimestre':
                    retorno meses / 3;
                caso 'ano':
                    retorno meses / 12;
            }
        } senão {
            // trata os milissegundos separadamente devido a erros matemáticos de ponto flutuante (questão #1867)
            dias = this._days + Math.round(monthsToDays(this._months));
            interruptor (unidades) {
                caso 'semana':
                    retornar dias / 7 + milissegundos / 6048e5;
                caso 'dia':
                    retornar dias + milissegundos / 864e5;
                caso 'hora':
                    dias de retorno * 24 + milissegundos / 36e5;
                caso 'minuto':
                    dias de retorno * 1440 + milissegundos / 6e4;
                caso 'segundo':
                    dias de retorno * 86400 + milissegundos / 1000;
                // Math.floor evita erros matemáticos de ponto flutuante aqui
                caso 'milissegundo':
                    return Math.floor(dias * 864e5) + milissegundos;
                predefinição:
                    throw new Error('Unknown unknown' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    função valorDe$1() {
        if (!this.isValid()) {
            retornar NaN;
        }
        Retorna (
            this._milissegundos +
            this._days * 864e5 +
            (este._meses % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs(alias) {
        função de retorno () {
            return this.as(alias);
        };
    }

    var asMilisegundos = makeAs('ms'),
        asSegundos = makeAs('s'),
        asMinutos = makeAs('m'),
        asHoras = makeAs('h'),
        asDias = makeAs('d'),
        asWeeks = makeAs('w'),
        asMeses = makeAs('M'),
        asQuarters = makeAs('Q'),
        asAnos = makeAs('y');

    função clone$1() {
        return createDuration(this);
    }

    função get$2(unidades) {
        unidades = normalizeUnidades(unidades);
        return this.isValid() ? this[unidades + 's']() : NaN;
    }

    function makeGetter(nome) {
        função de retorno () {
            return this.isValid() ? this._data[nome] : NaN;
        };
    }

    var milissegundos = makeGetter('milissegundos'),
        segundos = makeGetter('segundos'),
        minutos = makeGetter('minutos'),
        horas = makeGetter('horas'),
        dias = makeGetter('dias'),
        meses = makeGetter('meses'),
        anos = makeGetter('anos');

    função semanas() {
        return absFloor(this.days() / 7);
    }

    var rodada = Math.round,
        limites = {
            ss: 44, // alguns segundos a segundos
            s: 45, // segundos para minuto
            m: 45, // minutos para hora
            h: 22, // horas ao dia
            d: 26, // dias a mês/semana
            w: null, // semanas a mês
            M: 11, // meses a ano
        };

    // função auxiliar para moment.fn.from, moment.fn.fromNow e moment.duration.fn.humanize
    function substitutoTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
        var duração = createDuration(posNegDuration).abs(),
            segundos = round(duration.as('s')),
            minutos = rodada(duração.as('m')),
            horas = rodada(duração.as('h')),
            dias = rodada(duração.as('d')),
            meses = rodada(duração.as('M')),
            semanas = rodada(duração.as('w')),
            anos = round(duration.as('y')),
            a =
                (segundos <= thresholds.ss && ['s', segundos]) ||
                (segundos < thresholds.s && ['ss', segundos]) ||
                (minutos <= 1 && ['m']) ||
                (minutos < limiares.m && ['mm', minutos]) ||
                (horas <= 1 && ['h']) ||
                (horas < thresholds.h && ['hh', horas]) ||
                (dias <= 1 && ['d']) ||
                (days < thresholds.d && ['dd', dias]);

        if (thresholds.w != null) {
            a =
                a ||
                (semanas <= 1 && ['w']) ||
                (semanas < thresholds.w && ['ww', semanas]);
        }
        a = a ||
            (meses <= 1 && ['M']) ||
            (meses < limiares.M && ['MM', meses]) ||
            (anos <= 1 && ['y']) || ['aa', anos];

        a[2] = semSufixo;
        a[3] = +posNegDuration > 0;
        a[4] = localidade;
        return substitutoTimeAgo.apply(null, a);
    }

    // Esta função permite definir a função de arredondamento para strings de tempo relativo
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === indefinido) {
            volta de volta;
        }
        if (typeof roundingFunction === 'function') {
            rodada = função de arredondamento;
            retorne verdadeiro;
        }
        retorna falso;
    }

    // Esta função permite que você defina um limite para strings de tempo relativo
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (limites[limite] === indefinido) {
            retorna falso;
        }
        if (limite === indefinido) {
            limiares de retorno[limiar];
        }
        limites[limiar] = limite;
        if (limiar === 's') {
            thresholds.ss = limite - 1;
        }
        retorne verdadeiro;
    }

    function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var withSuffix = false,
            th = limites,
            localidade,
            resultado;

        if (typeof argWithSuffix === 'objeto') {
            argThresholds = argWithSuffix;
            argComSufixo = false;
        }
        if (typeof argWithSuffix === 'boolean') {
            comSufixo = argComSufixo;
        }
        if (typeof argThresholds === 'objeto') {
            th = Object.assign({}, limites, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
                th.ss = argThresholds.s - 1;
            }
        }

        locale = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale);

        if (com sufixo) {
            saída = locale.pastFuture(+this, saída);
        }

        return locale.postformat(saída);
    }

    var abs$1 = Math.abs;

    função sinal(x) {
        return (x > 0) - (x < 0) || +x;
    }

    function paraISOString$1() {
        // para strings ISO não usamos as regras normais de borbulhamento:
        // * milissegundos borbulham até se tornarem horas
        // * os dias não borbulham
        // * meses borbulham até se tornarem anos
        // Isso ocorre porque não há conversão livre de contexto entre horas e dias
        // (pense em mudanças de relógio)
        // e também não entre dias e meses (28-31 dias por mês)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var segundos = abs$1(this._milliseconds) / 1000,
            dias = abs$1(this._days),
            meses = abs$1(este._meses),
            minutos,
            horas,
            anos,
            s,
            total = this.asSeconds(),
            totalSinal,
            ymSign,
            diasSinal,
            hmsSinal;

        if (!total) {
            // isso é o mesmo que C# (Noda) e python (isodate)...
            // mas não outro JS (goog.date)
            retornar 'P0D';
        }

        // 3600 segundos -> 60 minutos -> 1 hora
        minutos = absFloor(segundos / 60);
        horas = absFloor(minutos / 60);
        segundos %= 60;
        minutos %= 60;

        // 12 meses -> 1 ano
        anos = absFloor(meses / 12);
        meses %= 12;

        // inspirado em https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        s = segundos? segundos.paraFixed(3).replace(/\.?0+$/, '') : '';

        totalSign = total < 0 ? '-':'';
        ymSign = sign(this._months) !== sign(total) ? '-':'';
        daysSign = sign(this._days) !== sign(total) ? '-':'';
        hmsSign = sign(this._milliseconds) !== sign(total) ? '-':'';

        Retorna (
            totalSign +
            'P' +
            (anos ? ymSign + anos + 'Y' : '') +
            (meses ? ymSign + meses + 'M' : '') +
            (dias ? diasSinal + dias + 'D' : '') +
            (horas || minutos || segundos ? 'T' : '') +
            (horas ? hmsSign + horas + 'H' : '') +
            (minutos ? hmsSign + minutos + 'M' : '') +
            (segundos ? hmsSign + s + 'S' : '')
        );
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.adicionar = adicionar$1;
    proto$2.subtrair = subtrair$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutos;
    proto$2.asHoras = asHoras;
    proto$2.asDias = asDias;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valorOf$1;
    proto$2._bolha = bolha;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milissegundos = milissegundos;
    proto$2.segundos = segundos;
    proto$2.minutos = minutos;
    proto$2.horas = horas;
    proto$2.dias = dias;
    proto$2.semanas = semanas;
    proto$2.meses = meses;
    proto$2.anos = anos;
    proto$2.humanize = humanizar;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;

    proto$2.toIsoString = obsoleto(
        'toIsoString() está obsoleto. Por favor, use toISOString() em vez disso (observe as maiúsculas)',
        toISOString$1
    );
    proto$2.lang = lang;

    // FORMATAÇÃO

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // ANALISANDO

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (entrada, array, config) {
        config._d = new Date(parseFloat(input) * 1000);
    });
    addParseToken('x', function (entrada, array, config) {
        config._d = new Date(toInt(input));
    });

    //! momento.js

    hooks.version = '2.29.3';

    setHookCallback(createLocal);

    ganchos.fn = proto;
    ganchos.min = min;
    ganchos.max = max;
    ganchos.agora = agora;
    ganchos.utc = criarUTC;
    ganchos.unix = criarUnix;
    ganchos.meses = listMeses;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    ganchos.inválido = criarInválido;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    ganchos.isDuração = isDuração;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    ganchos.prototype = proto;

    // atualmente o tipo de entrada HTML5 suporta apenas formatos de 24 horas
    ganchos.HTML5_FMT = {
        DATETIME_LOCAL: 'AAAA-MM-DDTHH:mm', // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'AAAA-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'AAAA-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
        DATA: 'AAAA-MM-DD', // <input type="date" />
        TIME: 'HH:mm', // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
        SEMANA: 'GGGG-[W]WW', // <input type="week" />
        MÊS: 'AAAA-MM', // <input type="mês" />
    };

    ganchos de retorno;

})));